<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8"/>
<title>Relational-logische Programmierung</title>
<meta name="author" content="Johannes Brauer"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="./reveal.js/css/reveal.css"/>

<link rel="stylesheet" href="./reveal.js/css/theme/simple.css" id="theme"/>

<link rel="stylesheet" href="./mycss/myrevealstyle.css"/>

<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = './reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<link rel="stylesheet" type="text/css" href="mycss/mystyle.css" />
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide">
<h1 class="title">Relational-logische Programmierung</h1><h3 class="subtitle">Programmierparadigmen</h3><h2 class="author">Johannes Brauer</h2><h2 class="date"></h2>
</section>

<section>
<section id="slide-org1bf5b80">
<h2 id="org1bf5b80">Ziele</h2>
<ul>
<li>Vermittlung von Grundkenntnissen und Fertigkeiten der
logischen/prädikativen/relationalen Programmierung</li>
<li>Kennenlernen der Syntax und Semantik von Prolog</li>
<li>Ausführung von Prolog-Programen</li>

</ul>

</section>
</section>
<section>
<section id="slide-org5ccc908">
<h2 id="org5ccc908">Einführung</h2>
<ul>
<li>Relational-logische Programmierung: Programme spezifizieren
Relationen zwischen Größen.</li>
<li>Logische Programmierung: Programm mit Datenstrukturen: Listen,
Binärbäume, symbolische Ausdrücke, natürliche Zahlen.</li>
<li>Der Ursprung der logischen Programmierung: automatische Theorembeweiser.</li>
<li>Sie verlangt eine Änderung der Denkweise:
<ol>
<li>Strukturierte logische Formeln werden als Relations- (Prozedur-)
Spezifikationen betrachtet.</li>
<li>Eine Frage zu einer logischen Implikation wird als Relations-
(Prozedur-) Aufruf betrachtet.</li>
<li>Der Beweis der Implikation ist dann die Berechnung der Antwort.</li>

</ol></li>

</ul>

</section>
<section>

<ul>
<li>Konkreter: Ein Axiom der Form:<br />
<code>A if B1 and B2 ... and Bn</code><br />
kann als Prozedur in einer Programmiersprache betrachtet werden:
<ul>
<li><code>A</code> ist der Prozedurkopf,</li>
<li>die <code>Bis</code> bilden ihren Rumpf.</li>

</ul></li>
<li>Der Versuch <code>A</code> zu lösen, wird als Ausführung der Prozedur
verstanden. Dazu muss der Ausdruck <code>B1 and B2 ... and Bn</code> gelöst
bzw. ausgeführt werden.</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgd1a2272">
<h2 id="orgd1a2272">Relationale Programmierung mit Prolog</h2>
<ul>
<li>Prolog (Programming in Logic) wurde Anfang der 1970er Jahre von dem
französischen Informatiker Alain Colmerauer entwickelt.</li>
<li>Prolog hat sich als Programmiersprache über die strikte logische
Basis hinaus entwickelt: Praktische Programmierkonstrukte wie
arithmetische Operationen, Optimierungshilfmittel und Ein-/Ausgabe
sind hinzugekommen.</li>
<li>Die Darstellungen in den folgenden Abschnitten basieren auf
<a class="org-ref-reference" href="#/slide-bibliography">[Bramer2013]</a> und  <a class="org-ref-reference" href="#/slide-bibliography">[Clocksin2003]</a>.</li>

</ul>

</section>
<section id="slide-orgcaa2277">
<h3 id="orgcaa2277">Syntax und Semantik relational-logischer Programme</h3>
<ul>
<li>Die Syntax basiert auf einer Teilmenge der Prädikatenkalküls. Ein
relational-logisches Programm besteht aus einer Menge von Formeln,
 die nach Fakten und Regeln unterschieden werden. Beide beschreiben
 bekannte Relationen auf der Problemdomäne.</li>
<li>Die Semantik besteht in einer Menge von Antworten auf Fragen.</li>
<li>Ein Programm wird ausgeführt durch eine logische Aussage, die auch
Frage oder <i>Zielausdruck</i> (oder goal oder query) genannt wird.</li>
<li>Fragen können Variablen enthalten.</li>
<li>Die Beantwortung von Fragen mit Variablen besteht darin,
Variablenbindungen zu finden, die die Frage „beweisen“.</li>
<li>Dies geschieht mithilfe zweier Techniken:
<ul>
<li>Unifikation: Belegung von Variablen in zwei Termen, so dass diese
gleich werden.</li>
<li>Backtracking: Suchstrategie bei der Beweisfindung.</li>

</ul></li>
<li>Es gibt nur eine primitive Operation: den Unifikationsoperator
<code>=</code>.</li>
<li>Es gibt keine Typen.</li>

</ul>
</section>
<section id="slide-orga274037">
<h3 id="orga274037">Einstiegsbeispiel</h3>
<ul>
<li>Das „Hallo Welt“-Äquivalent für ein Prolog-Programm ist meistens
eine Wissensdatenbank mit Verwandtschaftsverhältnissen.
<ul>
<li>Eltern: Paul, Elfriede</li>
<li>Kinder: Klaus, Claudia, Monika</li>

</ul></li>
<li><p>
Fakten in Prolog:
</p>
<div class="org-src-container">

<pre  class="src src-prolog">  vater(klaus, paul).
  vater(claudia, paul).
  vater(monika, paul).
  mutter(klaus, elfriede).
  mutter(claudia, elfriede).
  mutter(monika, elfriede).
  verheiratet(paul, elfriede).
</pre>
</div></li>

</ul>

</section>
<section id="slide-orgef81103">
<h4 id="orgef81103">Start des Prolog-Interpreters</h4>
<ul>
<li>Im folgenden wird <a href="http://www.swi-prolog.org">SWI-Prolog</a> benutzt.</li>
<li>Nach dem Start des Interpreters und der Konsultation der Faktendatei
<code>stammbaum.pl</code> können Fragen an den Interpreter gestellt werden:</li>

</ul>
<div class="org-src-container">

<pre  class="src src-prolog"><span style="color: #BA36A5;">Welcome</span> to <span style="color: #BA36A5;">SWI</span>-<span style="color: #BA36A5;">Prolog</span> (threaded, 64 bits, version 7.4.2)
<span style="color: #BA36A5;">SWI</span>-<span style="color: #BA36A5;">Prolog</span> comes with <span style="color: #BA36A5;">ABSOLUTELY</span> <span style="color: #BA36A5;">NO</span> <span style="color: #BA36A5;">WARRANTY</span>. <span style="color: #BA36A5;">This</span> is free software.
<span style="color: #BA36A5;">Please</span> run ?- license. <span style="color: #006699;">for</span> legal details.

<span style="color: #BA36A5;">For</span> online help and background, visit http://www.<span style="color: #006699;">swi</span>-prolog.<span style="color: #006699;">org</span>
<span style="color: #BA36A5;">For</span> built-in help, use ?- help(<span style="color: #BA36A5;">Topic</span>). <span style="color: #006699;">or</span> ?- apropos(<span style="color: #BA36A5;">Word</span>).

1 ?- consult(<span style="color: #008000;">'stammbaum.pl'</span>).
true.

2 ?- vater(klaus, paul).
true.

3 ?- mutter(claudia, paul).
false.
</pre>
</div>
</section>
<section id="slide-orgb4554c3">
<h4 id="orgb4554c3">Weitere Beispiele für Fragen (Zielausdrücke, goals):</h4>
<p>
Fragen können Variablen benutzen, die stets mit einem Großbuchstaben
beginnen müssen.
</p>
<div class="org-src-container">

<pre  class="src src-prolog">?-  mutter(klaus, elfriede).
    true.
?-  vater(claudia, <span style="color: #BA36A5;">X</span>).
    <span style="color: #BA36A5;">X</span>=paul.
?-  vater(peter, <span style="color: #BA36A5;">X</span>).
    false.
?-  vater(<span style="color: #BA36A5;">X</span>, paul).
    <span style="color: #BA36A5;">X</span>=klaus<span style="color: #0000FF;">;</span>
    <span style="color: #BA36A5;">X</span>=claudia<span style="color: #0000FF;">;</span>
    <span style="color: #BA36A5;">X</span>=monika.
?-  verheiratet(<span style="color: #BA36A5;">X</span>, <span style="color: #BA36A5;">Y</span>).
    <span style="color: #BA36A5;">X</span>=paul<span style="color: #0000FF;">;</span>
    <span style="color: #BA36A5;">Y</span>=elfriede.
</pre>
</div>
</section>
<section id="slide-org4744365">
<h4 id="org4744365">Regeln</h4>
<p>
Nehmen wir an, wir möchten auch Anfragen über die
Schwesterbeziehung in die Datenbasis aufnehmen, um entsprechende
Anfragen beantworten zu können. Dann hat man zwei Möglichkeiten:
</p>
<ol>
<li><p>
Neue Fakten hinzufügen:
</p>
<div class="small">
<div class="org-src-container">

<pre  class="src src-prolog">   schwester(claudia, monika).
   schwester(monika, claudia).
   schwester(klaus, claudia).
   schwester(klaus, monika).
</pre>
</div>

</div></li>
<li>Formulierung einer Regel: <code>Y</code> ist Schwester von <code>X</code>, falls <code>Y</code> 
weiblich und Mutter von <code>X</code> gleich Mutter von <code>Y</code> ist und Vater von
<code>X</code> gleich Vater von <code>Y</code>.<br />
Dann muss man nur noch als Fakten festhalten, welche
Familienmitglieder weiblich sind. Die Regel erlaubt es, aus bekannten 
Fakten neue herzuleiten!</li>

</ol>

</section>
<section id="slide-orgf432167">
<h4 id="orgf432167">Prolog-Programm mit Schwesterregel</h4>
<p>
Fakten:
</p>
<div class="org-src-container">

<pre  class="src src-prolog"><span style="color: #006699;">vater</span>(klaus, paul).
<span style="color: #006699;">vater</span>(claudia, paul).
<span style="color: #006699;">vater</span>(monika, paul).
<span style="color: #006699;">mutter</span>(klaus, elfriede).
<span style="color: #006699;">mutter</span>(claudia, elfriede).
<span style="color: #006699;">mutter</span>(monika, elfriede).
<span style="color: #006699;">verheiratet</span>(paul, elfriede).
<span style="color: #006699;">weiblich</span>(claudia).
<span style="color: #006699;">weiblich</span>(monika).
<span style="color: #006699;">weiblich</span>(elfriede).
</pre>
</div>

<p>
Regeln:
</p>
<div class="small">
<div class="org-src-container">

<pre  class="src src-prolog"><span style="color: #006699;">schwester</span>(<span style="color: #BA36A5;">X</span>, <span style="color: #BA36A5;">Y</span>):- weiblich(<span style="color: #BA36A5;">Y</span>), 
       mutter(<span style="color: #BA36A5;">X</span>, <span style="color: #BA36A5;">Z</span>), mutter(<span style="color: #BA36A5;">Y</span>, <span style="color: #BA36A5;">Z</span>), 
       vater(<span style="color: #BA36A5;">X</span>, <span style="color: #BA36A5;">W</span>), vater(<span style="color: #BA36A5;">Y</span>, <span style="color: #BA36A5;">W</span>),
       <span style="color: #BA36A5;">X</span> \== <span style="color: #BA36A5;">Y</span>.
</pre>
</div>

</div>

</section>
<section id="slide-org7cf94e9">
<h4 id="org7cf94e9">Beispielanfragen</h4>
<div class="smaller">
<div class="org-src-container">

<pre  class="src src-prolog">?- schwester(klaus, claudia).
</pre>
</div>

</div>

<p>
Das Prolog-System muss
</p>

<ol>
<li>prüfen, ob <code>claudia</code> weiblich ist (Faktum)</li>
<li>erkennen, dass <code>mutter(klaus,Z)</code> und <code>mutter(claudia,Z)</code> gelten für
<code>Z=elfriede</code></li>
<li>erkennen, dass <code>vater(klaus,W)</code> und <code>vater(claudia,W)</code> gelten für
<code>W=Paul</code></li>
<li>daher <code>true</code> ausgeben</li>

</ol>

</section>
<section>

<div class="smaller">
<div class="org-src-container">

<pre  class="src src-prolog">?- schwester(klaus, <span style="color: #BA36A5;">X</span>).
</pre>
</div>

</div>

<ul>
<li>Die Frage bedeutet: Wer sind die Schwestern von Klaus?</li>
<li>Das Prolog-System durchsucht seine Datenbank von Fakten (und Regeln)
in fester Reihenfolge; nämlich:
<ol>
<li>von oben nach unten</li>
<li>von links nach rechts</li>

</ol></li>
<li><p>
Daher liefert die Anfrage die Antwort:
</p>

<div class="small">
<div class="org-src-container">

<pre  class="src src-prolog">   <span style="color: #BA36A5;">X</span>=claudia<span style="color: #0000FF;">;</span>
   <span style="color: #BA36A5;">X</span>=monika<span style="color: #0000FF;">;</span>
   false.
</pre>
</div>

</div></li>

</ul>

</section>
<section>

<div class="smaller">
<div class="org-src-container">

<pre  class="src src-prolog">?- schwester(<span style="color: #BA36A5;">X</span>, <span style="color: #BA36A5;">Y</span>).
</pre>
</div>

</div>

<p>
Es ist nicht schwer zu sehen, dass aufgrund der o.g. Auswertestrategie
folgende Ausgabe erzeugt wird:
</p>

<div class="small">
<div class="org-src-container">

<pre  class="src src-prolog"><span style="color: #BA36A5;">X</span> = klaus, <span style="color: #BA36A5;">Y</span> = claudia <span style="color: #0000FF;">;</span>
<span style="color: #BA36A5;">X</span> = monika, <span style="color: #BA36A5;">Y</span> = claudia <span style="color: #0000FF;">;</span>
<span style="color: #BA36A5;">X</span> = klaus, <span style="color: #BA36A5;">Y</span> = monika <span style="color: #0000FF;">;</span>
<span style="color: #BA36A5;">X</span> = claudia, <span style="color: #BA36A5;">Y</span> = monika <span style="color: #0000FF;">;</span>
false.
</pre>
</div>

</div>
</section>
<section id="slide-org796a70c">
<h4 id="org796a70c">modus ponens</h4>
<ul>
<li>Die oben gezeigten Ableitungen basieren auf dem <i>modus ponens</i>,
einer Schlussregel der Logik:<br />
Aus den Prämissen <i>Wenn A dann B</i> und <i>A</i> lässt sich <i>B</i>
schlussfolgern.</li>
<li>Mit anderen Worten: Der logische Ausdruck
\[((A\to B)\wedge A)\to B\]
ist eine Tautologie.</li>
<li>Die oben genannte Beispielanfrage <code>schwester(klaus, claudia).</code>
entspricht dem <i>B</i>.</li>
<li><p>
Die rechte Seite der Schwesterregel
</p>
<pre class="example">
weiblich(Y), mutter(X, Z), mutter(Y, Z), vater(X, W), vater(Y, W), X \== Y.
</pre>

<p>
entpricht dem <i>A</i>. Wenn also <i>A</i> bewiesen werden kann,
d.&nbsp;h. eine Belegung der Variablen <code>X, Y, W</code> und <code>Z</code> gefunden
werden kann, für die alle Teilausdrücke von <i>A</i> wahr werden, ist
auch <i>B</i> bewiesen. 
</p></li>

</ul>
</section>
<section id="slide-org07d9ad6">
<h3 id="org07d9ad6">Basiskonzepte von Prolog</h3>
<div class="outline-text-3" id="text-org07d9ad6">
</div>
</section>
<section id="slide-org23e5c7c">
<h4 id="org23e5c7c">Terme</h4>
<ul>
<li>Alle Daten (einschließlich der Prolog-Programme) in Prolog werden
durch <i>Terme</i> repräsentiert.</li>
<li>Ein Term ist:
<dl>
<dt>ein <i>Atom</i></dt><dd>Beispiele sind <code>elmshorn</code>, <code>claudia</code>. Atome beginnen
mit einem Kleinbuchstaben.</dd>
<dt>eine <i>Variable</i></dt><dd>Variablen beginnen mit einem Großbuchstaben oder
dem Unterstrich. Ein singulärer Unterstrich bezeichnet die
<i>anonyme Variable</i>, die für „irgendeinen Term” steht.</dd>
<dt>eine <i>Ganzzahl</i> oder eine <i>Gleitkommazahl</i></dt><dd></dd>

<dt>ein <i>zusammengesetzter Term</i> (compound term)</dt><dd>Wenn \(t_1, t_2, \ldots ,t_n\) Terme sind, dann ist auch \(f(t_1,
      t_2, \ldots ,t_n)\) ein Term. &nbsp; \(f\) heißt Funktor und \(n\) ist die
  Stelligkeit (arity) des zusammen&#x00ad;gesetzten Terms.<br />
  Beispiele: <code>f(a)</code>, <code>g(f(X))</code>, <code>+(a, f(X))</code></dd>

</dl></li>

</ul>
</section>
<section id="slide-org175c045">
<h5 id="org175c045">Übersicht</h5>

<div class="figure">
<p><img src="./Abbildungen/prologterme.png" alt="prologterme.png" width="750px" />
</p>
</div>
</section>
<section id="slide-org5aff799">
<h5 id="org5aff799">Stelligkeit</h5>
<ul>
<li>In Prolog können zwei Prädikate mit demselben Funktor aber
unterschiedlicher Stelligkeit definiert werden.</li>
<li>Prolog behandelte diese als zwei verschiedene Prädikate.</li>
<li>In der Prolog-Dokumentation wird die Stelligkeit eines Prädikats
durch Anhängen von "/" gefolgt von der Zahl, die die Stelligkeit
angibt, dargestellt.</li>

</ul>
</section>
<section id="slide-org21e9330">
<h5 id="org21e9330">Anwendungsbeispiel für geschachtelte komplexe Terme</h5>
<div class="small">
<div class="org-src-container">

<pre  class="src src-prolog"><span style="color: #006699;">vertical</span>(line(point(<span style="color: #BA36A5;">X</span>,<span style="color: #BA36A5;">Y</span>), point(<span style="color: #BA36A5;">X</span>,<span style="color: #BA36A5;">Y2</span>))).
<span style="color: #006699;">horizontal</span>(line(point(<span style="color: #BA36A5;">X</span>,<span style="color: #BA36A5;">Y</span>), point(<span style="color: #BA36A5;">X2</span>,<span style="color: #BA36A5;">Y</span>))).
</pre>
</div>

</div>
<p>
Welche Antworten liefert Prolog auf die folgenden Fragen:
</p>
<div class="org-src-container">

<pre  class="src src-prolog">?- vertical(line(point(5,6), point(5,7))).
???

?- horizontal(line(point(5,6), point(5,7))).
???

?- horizontal(line(point(5,6), point(5,<span style="color: #BA36A5;">X</span>))).
???

?- vertical(line(point(5,6), <span style="color: #BA36A5;">X</span>)).
???
</pre>
</div>
</section>
<section id="slide-orgbdcc186">
<h4 id="orgbdcc186">Programme</h4>
<ul>
<li>Ein Prolog-Programm besteht aus einer Menge von Prädikaten.</li>
<li>Prädikate beschreiben Relationen zwischen ihren Argumenten. Logisch
betrachtet beschreibt ein Prolog-Programm, was gilt.</li>
<li>Jedes <i>Prädikat</i> besitzt ein Atom als Namen und beliebig viele Argumente.</li>
<li>Jedes Argument ist ein Prolog-Term.</li>
<li>Ein Prädikat mit dem Namen <code>Pred</code> und \(n\) Argumenten wird durch
einen Prädikatsindikator notiert: <code>Pred/n</code>. \(n\) ist die Stelligkeit
des Prädikats.</li>
<li>Ein Prädikat wird durch eine Menge von <i>Klauseln</i> (s. u.) definiert.</li>
<li>Die Klauseln, die ein Prädikat definieren, stellen logische
Alternativen dar. Wenn eine der Klauseln wahr ist, ist das ganze
Prädikat war.</li>

</ul>
</section>
<section id="slide-org8176114">
<h4 id="org8176114">Klauseln &#x2013; Regeln</h4>
<ul>
<li>Ein Klausel ist entweder ein <i>Fakt</i> oder eine <i>Regel</i>.</li>
<li>Eine Regel hat die Form:<br />
<code>Kopf :- Rumpf.</code>
<ul>
<li>Die Form des <code>Kopf</code> hängt von der Zahl der Argumente des Prädikats
ab:
<ul>
<li>Besitzt das Prädikat keine Argumente, dann besteht der <code>Kopf</code>
nur aus dem Namen des Prädikats, ist also ein Atom.</li>
<li>Andernfalls ist <code>Kopf</code> ein zusammengesetzter Term, z. B.:<br />
<code>schwester(X, Y)</code></li>

</ul></li>
<li>Der <code>Rumpf</code> hat die Form: \(B_1,\ldots,B_n\), wobei die \(B_i\) Terme
sind, die mit dem Komma konjunktiv verknüpft sind.</li>
<li>Die Zeichenfolge <code>:-</code> steht für die logische Implikation,
gerichtet vom Rumpf zum Kopf.</li>

</ul></li>

</ul>
</section>
<section>
<ul>
<li><p>
Z. B. kann die Regel<br />
</p>
<pre class="example">
father(Dad, Child) :- parent(Dad, Child), male(Dad).
</pre>

<p>
wie folgt gelesen werden: <code>Dad</code> (eine Variable) ist <code>father</code> von
<code>Child</code> (Variable), wenn <code>Dad</code> <code>parent</code> von <code>Child</code> und <code>Dad</code>
<code>male</code> ist.
</p></li>

</ul>
</section>
<section id="slide-orgf08e55f">
<h4 id="orgf08e55f">Klauseln &#x2013; Fakten</h4>
<ul>
<li>Ein Faktum wird so aufgeschrieben:<br />
<code>Kopf.</code></li>
<li>Dieser Ausdruck ist äquivalent zur Regel:<br />
<code>Kopf :- true.</code></li>
<li>Logisch bedeutet das, dass die Regel immer wahr ist, weil das
Standardprädikat <code>true/0</code> immer wahr ist.</li>

</ul>
</section>
<section id="slide-orgae587de">
<h4 id="orgae587de">Starten von Prolog-Programmen</h4>
<ul>
<li>Eingabe von Fragen/Zielausdrücken (queries) am Eingabeprompt des
Prolog-Interpreters</li>
<li>Ein Zielausdruck besteht aus dem Namen eines beliebigen Prädikats
und seiner Argumente.</li>
<li>Eine Frage kann aus der Und-Verknüpfung von mehreren Zielausdrücken
bestehen.</li>
<li>In einer Frage sind Variabeln existenz-quantifiziert. Eine Frage
<code>p(X)</code> kann so gelesen werden: Existiert eine Variablenbindung für
X, so dass <code>p(X)</code> wahr wird.</li>
<li>Wenn eine passende Variablenbindung gefunden werden kann (the goal
succeeds), antwortet der Interpreter mit einem logisch äquivalenten
Zielausdruck.</li>
<li>Wenn eine Frage mehrere Antworten hat, liefert der Interpreter die
übrigen auf besondere Anforderung (in SWI-Prolog durch Eingabe von
Leerzeichen oder Semikolon).</li>

</ul>

</section>
<section id="slide-orgdb01d6d">
<h4 id="orgdb01d6d">Ausführung von Prolog-Programmen</h4>
<p>
Die operationale Semantik von Prolog
</p>
<ul>
<li>Die Ausführung von Prolog-Code kann als ein Spezialfall einer
<i>Resolution</i> betrachtet werden.</li>
<li>Die Resolution ist ein Verfahren der formalen Logik, um die
Gültigkeit einer logischen Formel zu prüfen. Dabei wird versucht,
aus der Verneinung der Frage einen Widerspruch abzuleiten.</li>
<li>Wenn ein Widerspruch gefunden wird, ist die Frage die logische
Folgerung aus dem Programm.</li>
<li>Ein wichtiger Schritt in diesem Prozess ist die Unifikation von
Termen.</li>
<li>Wird der Kopf einer Klausel für die Unifikation mit einem
Zielausdruck ausgewählt, wird diese auf die Argumente von beiden
Termen angewendet.</li>
<li>Daraus folgt, dass es in Prolog keine Unterscheidung zwischen Ein-
und Ausgabeparametern gibt.
(Vgl. <a href="PP2-7-RelProgUebrscht.html#/slide-beispiel-natuerliche-zahlen">Implementierung von natürlichen Zahlen</a>!)</li>

</ul>
</section>
<section>
<ul>
<li>Sind die Köpfe mehrerer Klauseln mit einem Zielausdruck
unifizierbar, werden die Alternativen durch <i>Backtracking</i>
abgearbeitet.</li>
<li>Informell kann die Ausführungsstrategie von Prolog als Tiefensuche
(depth-first search) mit <i>chronologischem Backtracking</i> betrachtet
werden (nähere Erläuterung s.&nbsp;u.).</li>

</ul>
</section>
<section id="slide-org147c9c5">
<h4 id="org147c9c5">Unifikation</h4>
<div class="outline-text-4" id="text-org147c9c5">
</div>
</section>
<section id="slide-orgd3e71fe">
<h5 id="orgd3e71fe">Informelle Definition:</h5>
<blockquote>
<p>
Zwei Terme sind unifizierbar, wenn sie identisch sind oder Variablen
enthalten, die einheitlich mit Termen so belegt werden können, dass
sie gleich (unifiziert) sind.
</p>
</blockquote>
<ul>
<li>Beispiele:
<ul>
<li>karin und karin sind unifiziert.</li>
<li>42 und 42 sind unifiziert.</li>
<li>weiblich(karla) und weiblich(karla) sind unifiziert.</li>
<li>klara und rosa sind nicht unifizierbar.</li>
<li>weiblich(karla) und weiblich(rosa) sind nicht unifizierbar.</li>

</ul></li>

</ul>
</section>
<section>
<ul>
<li>Welche der folgenden Term-Paare sind unifizierbar?
<ul>
<li>rosa und X</li>
<li>weiblich(X) und weiblich(klara)</li>
<li>liebt(rosa,X) und liebt(X,karl)</li>

</ul></li>

</ul>
</section>
<section id="slide-orgd52268c">
<h5 id="orgd52268c">Präzise Definition</h5>
<ol>
<li>Sind \(t_1\) und \(t_2\) Konstanten, dann sind \(t_1\) und \(t_2\)
unifizierbar, wenn sie dasselbe Atom oder dieselbe Zahl sind.</li>
<li>Ist \(t_1\) eine Variable und \(t_2\) irgendein Term, dann sind \(t_1\)
und \(t_2\) unifizierbar, wenn \(t_1\) mit  \(t_2\) belegt wird (und umgekehrt).</li>
<li>Sind \(t_1\) und \(t_2\) komplexe Terme, dann sind sie unifizierbar, wenn:
<ol>
<li>sie denselben Funktor mit derselben Stelligkeit besitzen, <b>und</b></li>
<li>alle ihre korrespondierenden Argumente unifizierbar sind, <b>und</b></li>
<li>die Variablenbelegungen kompatibel sind.</li>

</ol></li>

</ol>
</section>
<section id="slide-org86a7326">
<h5 id="org86a7326">Anwendungsbeispiele für <code>=/2</code></h5>
<div class="org-src-container">

<pre  class="src src-prolog">?- claudia = claudia.
... .

?- claudia = claudius.
... .

?- claudia = <span style="color: #BA36A5;">X</span>.
... .

?- <span style="color: #BA36A5;">X</span> = claudia, <span style="color: #BA36A5;">X</span> = claudius.
... .

?- k(s(g),<span style="color: #BA36A5;">Y</span>) = k(<span style="color: #BA36A5;">X</span>,t(k)).
... ,
...  .

?- father(<span style="color: #BA36A5;">X</span>) = <span style="color: #BA36A5;">X</span>.
... .
</pre>
</div>
</section>
<section id="slide-org6e41d6a">
<h4 id="org6e41d6a">Standardprädikate</h4>
<ul>
<li>Es gibt einige vordefinierte Standardprädikate, z. B.
<ul>
<li><code>=/2</code> ist wahr, wenn seine Argumente unifizierbar sind;</li>
<li><code>true/0</code> ist immer wahr, <code>false/0</code> immer falsch;</li>
<li><code>dif/2</code> is wahr genau dann, wenn die Argumente unterschiedliche
Terme sind;</li>
<li><code>,/2</code> bezeichnet die Konjunktion, <code>;/2</code> die Disjunktion.</li>

</ul></li>
<li>Standardprädikate für den Vergleich von Zahlen (alle zweistellig):
<ul>
<li><code>=:=</code>, <code>=\=</code> numerische Gleichheit, Ungleichheit</li>
<li><code>&lt;</code>, <code>&gt;</code>, <code>=&lt;</code>, <code>&gt;=</code></li>

</ul></li>
<li>Arithmetische Operationen (alle zweistellig):<br />
<code>+ - * / // mod</code><br />
Es gelten die üblichen Vorrangregeln.</li>
<li>Die Standardprädikate für Zahlen können in Infixnotation geschrieben
werden, also <code>3 + 4</code> anstatt <code>+(3, 4)</code>.</li>

</ul>
</section>
<section>
<ul>
<li><p>
Beachte: Der Unifikationsoperator <code>=/2</code> bewirkt keine Auswertung
arithmetischer Ausdrücke, dafür steht der Operator <code>is/2</code> zur
Verfügung:
</p>
<div class="smaller">
<div class="org-src-container">

<pre  class="src src-prolog">  ?- <span style="color: #BA36A5;">X</span> = 3 + 4.
  <span style="color: #BA36A5;">X</span> = 3+4.
  ?- <span style="color: #BA36A5;">X</span> is 3+4.
  <span style="color: #BA36A5;">X</span> = 7.
</pre>
</div>

</div></li>

</ul>

</section>
<section id="slide-org435707b">
<h4 id="org435707b">Resolution / Backtracking</h4>
<ul>
<li>Resolution: Grundlage für eine automatische Beweisführung</li>
<li>basiert auf dem Prinzip der Unifikation und des automatischen
Rücksetzens (Backtracking).</li>
<li>Prolog benutzt Tiefensuche; Reihenfolge der Klauseln entscheidend</li>
<li>Teilziele einer Anfrage werden von links nach rechts bearbeitet.</li>
<li>Zu jedem Teilziel wird die im Programmtext erste Klausel ausgewählt
und versucht mit dem Teilziel zu unifizieren.</li>
<li>Ist die Klausel eine Regel, so wird das Teilziel durch den
Regelrumpf ersetzt und versucht zu beweisen. Andernfalls wird
versucht das nächste Ziel der Anfrage herzuleiten.</li>
<li>Tritt während der Resolution ein Fehler bei der Unifikation auf,
wird also keine passende Programmklausel gefunden, so springt das
PROLOG-System durch das eingebaute Rücksetzen auf den letzten Punkt
zurück, an dem eine Entscheidung getroffen wurde, hebt die an dieser
Stelle gemachten Variablenbindungen auf und wählt die nächste
alternative Klausel aus.</li>

</ul>
</section>
<section id="slide-org117b95c">
<h5 id="org117b95c">Beispiel</h5>
<div class="org-src-container">

<pre  class="src src-prolog"><span style="color: #006699;">father</span>(abraham,isaac).
<span style="color: #006699;">father</span>(haran,lot).
<span style="color: #006699;">father</span>(haran,milcah).
<span style="color: #006699;">father</span>(haran,yiscah).
<span style="color: #006699;">male</span>(isaac).
<span style="color: #006699;">male</span>(lot).
<span style="color: #006699;">female</span>(milcah).
<span style="color: #006699;">female</span>(yiscah).
<span style="color: #006699;">son</span>(<span style="color: #BA36A5;">X</span>,<span style="color: #BA36A5;">Y</span>) :- father(<span style="color: #BA36A5;">Y</span>,<span style="color: #BA36A5;">X</span>), male(<span style="color: #BA36A5;">X</span>).
<span style="color: #006699;">daughter</span>(<span style="color: #BA36A5;">X</span>,<span style="color: #BA36A5;">Y</span>) :- father(<span style="color: #BA36A5;">Y</span>,<span style="color: #BA36A5;">X</span>), female(<span style="color: #BA36A5;">X</span>).
</pre>
</div>
<p>
Nachfolgend wird die Resolution der Anfrage
</p>
<pre class="example">
daughter(X,haran).
</pre>

<p>
gezeigt.
</p>
</section>
<section>
<div class="nebeneinander">
<ol>
<li>Prolog sucht passende Programmklausel<br />
Unifikation <code>daughter(X,Y)</code> und <code>daughter(X,haran)</code> <br />
\(\rightarrow\) Substitution <code>Y=haran</code></li>

</ol>

</div>
<div class="nebeneinander">

<div class="figure">
<p><img src="./Abbildungen/bibel.png" alt="bibel.png" width="350px" />
</p>
</div>

</div>
<div class="clear">

</div>
<ol>
<li value="2">Das ursprüngliche Ziel wird durch den Regelrumpf ersetzt<br />
\(\rightarrow\) neue Zielanfrage: <code>father(haran,X), female(X).</code></li>
<li>linkes Teilziel wird ausgewählt: <code>father(haran,X)</code><br />
erste Programmklausel wird ausgewählt: <code>father(abraham,isaac).</code><br />
\(\rightarrow\) Unifikation nicht möglich<br />
\(\rightarrow\) Backtracking</li>
<li>nächste alternative Programmklausel wird ausgewählt: <code>father(haran,lot)</code><br />
\(\rightarrow\) Substitution <code>X=lot</code></li>

</ol>
</section>
<section>
<div class="nebeneinander">
<ol>
<li value="5">rechtes Teilziel wird ausgewählt und Substitution angewendet: <code>female(lot)</code><br />
\(\rightarrow\) keine passende Programmklausel vorhanden \(\rightarrow\) Backtracking</li>

</ol>

</div>
<div class="nebeneinander">

<div class="figure">
<p><img src="./Abbildungen/bibel.png" alt="bibel.png" width="350px" />
</p>
</div>

</div>
<div class="clear">

</div>
<ol>
<li value="6">Substitution <code>X=lot</code> wird aufgehoben, nächste Klausel im
Programmtext ausgewählt: <code>father(haran,milcah)</code> <br />
\(\rightarrow\) Substitution <code>X=milcah</code></li>
<li>rechtes Teilziel wird ausgewählt und Substitution angewendet:
<code>female(milcah)</code><br />
\(\rightarrow\) passende Programmklausel vorhanden
\(\rightarrow\) Prolog gibt die Substitution <code>X=milcah</code> aus</li>
<li>Durch Eingabe von <code>;</code> wird manuell Backtracking erzwungen um
alternative Lösungen zu finden</li>

</ol>
</section>
<section>
<div class="nebeneinander">
<ol>
<li value="9">Substitution <code>X=milcah</code> wird aufgehoben, nächste Klausel im
Programmtext ausgewählt: <code>father(haran,yiscah)</code> <br />
\(\rightarrow\) Substitution <code>X=yiscah</code></li>

</ol>

</div>
<div class="nebeneinander">

<div class="figure">
<p><img src="./Abbildungen/bibel.png" alt="bibel.png" width="350px" />
</p>
</div>

</div>
<div class="clear">

</div>
<ol>
<li value="10">rechtes Teilziel wird ausgewählt und Substitution angewendet:<br />
<code>female(yiscah)</code> <br />
\(\rightarrow\) passende Programmklausel vorhanden<br />
\(\rightarrow\) Prolog gibt die Substitution <code>X=yiscah.</code> aus und
schließt die Beantwortung der ursprünglichen Anfrage, da
keine Alternativen mehr vorhanden sind.</li>

</ol>
</section>
<section id="slide-org05fe1b9">
<h3 id="org05fe1b9">Rekursion</h3>
<ul>
<li>Davon, dass Prolog rekursive Regeln erlaubt, wurde schon in bei der
logischen <a href="PP2-7-RelProgUebrscht.html#/slide-beispiel-natuerliche-zahlen">Implementierung von natürlichen Zahlen</a> Gebrauch gemacht.</li>
<li>Weiteres Beispiel, das die Notwendigkeit, Regeln rekursiv
definieren zu können, deutlich macht.</li>
<li><p>
Modifikation des Stammbaum-Beispiels, zunächst ein paar Fakten:
</p>
<div class="smaller">
<div class="org-src-container">

<pre  class="src src-prolog">  mutter(klaus, elfriede).
  mutter(claudia, elfriede).
  mutter(elfriede, rosa).
  mutter(rosa, klara)
</pre>
</div>

</div></li>
<li><p>
Gesucht ein Prädikat, das erlaubt festzustellen, ob eine Person
Abkömmling einer anderen Person ist. Z.&nbsp;B. sollte die folgende
Frage mit <code>true</code> beantwortet werden:
</p>
<pre class="example">
abkoemmling(klara, elfriede). 
</pre></li>

</ul>
</section>
<section>
<ul>
<li><p>
Wie lautet das Prädikat <code>abkoemling(X,Y)</code>?<br />
</p>
<div class="small">
<div class="org-src-container">

<pre  class="src src-prolog">  mutter(klaus, elfriede).
  mutter(claudia, elfriede).
  mutter(elfriede, rosa).
  mutter(rosa, klara)
 
  abkoemling(<span style="color: #BA36A5;">X</span>,<span style="color: #BA36A5;">Y</span>) :- <span style="color: #8D8D84; font-style: italic;">% Y ist Abk&#246;mmling von X</span>
</pre>
</div>

</div>
<div class="fragment roll-in small">
<div class="org-src-container">

<pre  class="src src-prolog">  abkoemmling(<span style="color: #BA36A5;">X</span>,<span style="color: #BA36A5;">Y</span>) :- mutter(<span style="color: #BA36A5;">Y</span>,<span style="color: #BA36A5;">X</span>).
  abkoemmling(<span style="color: #BA36A5;">X</span>,<span style="color: #BA36A5;">Y</span>) :- mutter(<span style="color: #BA36A5;">Z</span>,<span style="color: #BA36A5;">X</span>), abkoemmling(<span style="color: #BA36A5;">Z</span>,<span style="color: #BA36A5;">Y</span>).
</pre>
</div>

</div>
<ul class="fragment roll-in">
<li>Warum ist Rekursion hier erforderlich?</li>

</ul></li>

</ul>
</section>
<section id="slide-orge4fd480">
<h3 id="orge4fd480">Listen in Prolog</h3>
<ul>
<li>Listen in Prolog ähneln bis auf die Syntax den aus Racket oder
Clojure bekannten.
<ul>
<li>Beispiel: <code>[3,4,5,6,7]</code></li>

</ul></li>
<li>Sie können heterogen sein.
<ul>
<li>Beispiel: <code>(a, 3, 2.0, f(a), g[X])</code></li>

</ul></li>
<li>Die leere Liste: <code>[]</code></li>
<li>Jede Liste außer der leeren besteht aus zwei Teilen: dem ersten Element (head) und
der Restliste (tail).</li>
<li>Der senkrechte Strich entspricht der aus den Lisp-Sprachen bekannten
<code>cons</code>-Funktion. 
<ul>
<li><p>
Beispiele:
</p>
<div class="small">
<div class="org-src-container">

<pre  class="src src-prolog">    ?- <span style="color: #0000FF;">[</span>a, b, c, d<span style="color: #0000FF;">]</span> = <span style="color: #0000FF;">[</span>a <span style="color: #0000FF;">|</span> <span style="color: #0000FF;">[</span>b, c, d<span style="color: #0000FF;">]]</span>.
    true.
    ?- <span style="color: #0000FF;">[</span><span style="color: #BA36A5;">H</span> <span style="color: #0000FF;">|</span> <span style="color: #BA36A5;">T</span><span style="color: #0000FF;">]</span> = <span style="color: #0000FF;">[</span>a, b, c, d<span style="color: #0000FF;">]</span>.
    <span style="color: #BA36A5;">H</span> = a,
    <span style="color: #BA36A5;">T</span> = <span style="color: #0000FF;">[</span>b, c, d<span style="color: #0000FF;">]</span>.    
</pre>
</div>

</div></li>

</ul></li>

</ul>
</section>
<section id="slide-org8dd23b5">
<h3 id="org8dd23b5">Beipiele für Listen-Prädikate</h3>
<div class="outline-text-3" id="text-org8dd23b5">
</div>
</section>
<section id="slide-org9aa895a">
<h4 id="org9aa895a"><code>member</code></h4>
<ul>
<li><p>
Die Frage <code>member(X, L)</code> soll genau dann <code>true</code> liefern, wenn <code>X</code> in
der Liste <code>L</code> vorkommt.
</p>
<div class="org-src-container">

<pre  class="src src-prolog"><span style="color: #006699;">member</span>(<span style="color: #BA36A5;">X</span>,<span style="color: #0000FF;">[</span><span style="color: #BA36A5;">X</span><span style="color: #0000FF;">|</span><span style="color: #BA36A5;">T</span><span style="color: #0000FF;">]</span>).                <span style="color: #8D8D84; font-style: italic;">% besser: member(X,[X|_]).</span>
<span style="color: #006699;">member</span>(<span style="color: #BA36A5;">X</span>,<span style="color: #0000FF;">[</span><span style="color: #BA36A5;">H</span><span style="color: #0000FF;">|</span><span style="color: #BA36A5;">T</span><span style="color: #0000FF;">]</span>) :- member(<span style="color: #BA36A5;">X</span>,<span style="color: #BA36A5;">T</span>). <span style="color: #8D8D84; font-style: italic;">% besser: member(X,[_|T]) :- member(X,T).</span>

?- member(a, <span style="color: #0000FF;">[</span>b, a, c<span style="color: #0000FF;">]</span>).
true 

?- member(a, <span style="color: #0000FF;">[</span>b, c, d<span style="color: #0000FF;">]</span>).
false

?- member(a, <span style="color: #0000FF;">[]</span>).
false.

?- member(<span style="color: #BA36A5;">X</span>, <span style="color: #0000FF;">[</span>a, b, c<span style="color: #0000FF;">]</span>).
<span style="color: #BA36A5;">X</span> = a <span style="color: #0000FF;">;</span>
<span style="color: #BA36A5;">X</span> = b <span style="color: #0000FF;">;</span>
<span style="color: #BA36A5;">X</span> = c <span style="color: #0000FF;">;</span>
false.
</pre>
</div></li>

</ul>

</section>
<section id="slide-org5281d1d">
<h4 id="org5281d1d"><code>count</code></h4>
<ul>
<li><p>
<code>count</code> soll die Anzahl der Elemente einer Liste ermitteln.
</p>
<ol>
<li>Die Anzahl der Elemente der leeren Liste ist \(0\).</li>
<li>Die Anzahl der Elemente der nicht-leeren Liste ist \(1 +
     count(T)\), wobei \(T\) die Restliste ist.</li>

</ol>
<div class="org-src-container">

<pre  class="src src-prolog"><span style="color: #006699;">count</span>(<span style="color: #0000FF;">[]</span>,0).
<span style="color: #006699;">count</span>(<span style="color: #0000FF;">[</span><span style="color: #BA36A5;">_</span><span style="color: #0000FF;">|</span><span style="color: #BA36A5;">T</span><span style="color: #0000FF;">]</span>,<span style="color: #BA36A5;">N</span>) :- count(<span style="color: #BA36A5;">T</span>, <span style="color: #BA36A5;">X</span>), <span style="color: #BA36A5;">N</span> is <span style="color: #BA36A5;">X</span>+1.

?- count(<span style="color: #0000FF;">[]</span>, <span style="color: #BA36A5;">N</span>).
<span style="color: #BA36A5;">N</span> = 0.

?- count(<span style="color: #0000FF;">[</span>a, b, c<span style="color: #0000FF;">]</span>, <span style="color: #BA36A5;">N</span>).
<span style="color: #BA36A5;">N</span> = 3.

?- count(<span style="color: #0000FF;">[</span>a, b, c<span style="color: #0000FF;">]</span>, 3).
true.

?- count(<span style="color: #0000FF;">[</span>a, <span style="color: #0000FF;">[</span>1, 2<span style="color: #0000FF;">]</span>, c<span style="color: #0000FF;">]</span>, 3).
true.

?- count(<span style="color: #BA36A5;">X</span>, 3).
<span style="color: #BA36A5;">X</span> = <span style="color: #0000FF;">[</span><span style="color: #BA36A5;">_6622</span>, <span style="color: #BA36A5;">_6628</span>, <span style="color: #BA36A5;">_6634</span><span style="color: #0000FF;">]</span> 
</pre>
</div></li>

</ul>
</section>
<section id="slide-orgdc7afe1">
<h5 id="orgdc7afe1">Endrekursive Variante mit akkumulierendem Parameter</h5>
<div class="org-src-container">

<pre  class="src src-prolog"><span style="color: #006699;">acCount</span>(<span style="color: #0000FF;">[</span><span style="color: #BA36A5;">_</span><span style="color: #0000FF;">|</span><span style="color: #BA36A5;">T</span><span style="color: #0000FF;">]</span>,<span style="color: #BA36A5;">A</span>,<span style="color: #BA36A5;">L</span>) :- <span style="color: #BA36A5;">An</span> is <span style="color: #BA36A5;">A</span>+1, acCount(<span style="color: #BA36A5;">T</span>,<span style="color: #BA36A5;">An</span>,<span style="color: #BA36A5;">L</span>). 
<span style="color: #006699;">acCount</span>(<span style="color: #0000FF;">[]</span>,<span style="color: #BA36A5;">A</span>,<span style="color: #BA36A5;">A</span>).

<span style="color: #006699;">countAcc</span>(<span style="color: #BA36A5;">L</span>,<span style="color: #BA36A5;">N</span>) :- acCount(<span style="color: #BA36A5;">L</span>,0,<span style="color: #BA36A5;">N</span>).

?- countAcc(<span style="color: #0000FF;">[</span>a, <span style="color: #0000FF;">[</span>1, 2<span style="color: #0000FF;">]</span>, c<span style="color: #0000FF;">]</span>, 3).
true.

<span style="color: #8D8D84;">%% </span><span style="color: #8D8D84; font-style: italic;">Benutzung der Trace-Funktion von SWI-Prolog</span>
?- trace.
true.

<span style="color: #0000FF;">[</span>trace<span style="color: #0000FF;">]</span> 10 ?- acCount(<span style="color: #0000FF;">[</span>a, b, c<span style="color: #0000FF;">]</span>,0,<span style="color: #BA36A5;">N</span>).
   <span style="color: #BA36A5;">Call</span>: (8) acCount(<span style="color: #0000FF;">[</span>a, b, c<span style="color: #0000FF;">]</span>, 0, <span style="color: #BA36A5;">_1850</span>) ? 
   <span style="color: #BA36A5;">Call</span>: (9) <span style="color: #BA36A5;">_2100</span> is 0+1 ? 
   <span style="color: #BA36A5;">Exit</span>: (9) 1 is 0+1 ? 
   <span style="color: #BA36A5;">Call</span>: (9) acCount(<span style="color: #0000FF;">[</span>b, c<span style="color: #0000FF;">]</span>, 1, <span style="color: #BA36A5;">_1850</span>) ? 
   <span style="color: #BA36A5;">Call</span>: (10) <span style="color: #BA36A5;">_2106</span> is 1+1 ? 
   <span style="color: #BA36A5;">Exit</span>: (10) 2 is 1+1 ? 
   <span style="color: #BA36A5;">Call</span>: (10) acCount(<span style="color: #0000FF;">[</span>c<span style="color: #0000FF;">]</span>, 2, <span style="color: #BA36A5;">_1850</span>) ? 
   <span style="color: #BA36A5;">Call</span>: (11) <span style="color: #BA36A5;">_2112</span> is 2+1 ? 
   <span style="color: #BA36A5;">Exit</span>: (11) 3 is 2+1 ? 
   <span style="color: #BA36A5;">Call</span>: (11) acCount(<span style="color: #0000FF;">[]</span>, 3, <span style="color: #BA36A5;">_1850</span>) ? 
   <span style="color: #BA36A5;">Exit</span>: (11) acCount(<span style="color: #0000FF;">[]</span>, 3, 3) ? 
   <span style="color: #BA36A5;">Exit</span>: (10) acCount(<span style="color: #0000FF;">[</span>c<span style="color: #0000FF;">]</span>, 2, 3) ? 
   <span style="color: #BA36A5;">Exit</span>: (9) acCount(<span style="color: #0000FF;">[</span>b, c<span style="color: #0000FF;">]</span>, 1, 3) ? 
   <span style="color: #BA36A5;">Exit</span>: (8) acCount(<span style="color: #0000FF;">[</span>a, b, c<span style="color: #0000FF;">]</span>, 0, 3) ? 
<span style="color: #BA36A5;">N</span> = 3.
</pre>
</div>
</section>
<section id="slide-org47485cb">
<h4 id="org47485cb"><code>append</code></h4>
<ul>
<li><p>
Die Frage <code>append(L1, L2, L3)</code> soll genau dann <code>true</code> liefern, wenn
die Liste <code>L3</code> gleich der Verkettung der Liste <code>L1</code> mit der Liste <code>L2</code> ist.
</p>
<div class="org-src-container">

<pre  class="src src-prolog"><span style="color: #006699;">append</span>(<span style="color: #0000FF;">[]</span>,<span style="color: #BA36A5;">L</span>,<span style="color: #BA36A5;">L</span>).
<span style="color: #006699;">append</span>(<span style="color: #0000FF;">[</span><span style="color: #BA36A5;">H</span><span style="color: #0000FF;">|</span><span style="color: #BA36A5;">T</span><span style="color: #0000FF;">]</span>,<span style="color: #BA36A5;">L2</span>,<span style="color: #0000FF;">[</span><span style="color: #BA36A5;">H</span><span style="color: #0000FF;">|</span><span style="color: #BA36A5;">L3</span><span style="color: #0000FF;">]</span>)  :-  append(<span style="color: #BA36A5;">T</span>,<span style="color: #BA36A5;">L2</span>,<span style="color: #BA36A5;">L3</span>).

?- append(<span style="color: #0000FF;">[</span>a,b,c<span style="color: #0000FF;">]</span>,<span style="color: #0000FF;">[</span>1,2,3<span style="color: #0000FF;">]</span>,<span style="color: #0000FF;">[</span>a,b,c,1,2,3<span style="color: #0000FF;">]</span>).
true.

?- append(<span style="color: #0000FF;">[</span>a,<span style="color: #0000FF;">[</span>b,c<span style="color: #0000FF;">]</span>,d<span style="color: #0000FF;">]</span>,<span style="color: #0000FF;">[</span>1,2,3<span style="color: #0000FF;">]</span>,<span style="color: #0000FF;">[</span>a,<span style="color: #0000FF;">[</span>b,c<span style="color: #0000FF;">]</span>,d,1,2,3<span style="color: #0000FF;">]</span>).
true.

?- append(<span style="color: #0000FF;">[</span>a,b,c<span style="color: #0000FF;">]</span>,<span style="color: #0000FF;">[</span>1,2,3<span style="color: #0000FF;">]</span>,<span style="color: #0000FF;">[</span>1,2,3,a,b,c<span style="color: #0000FF;">]</span>).
false.

?- append(<span style="color: #0000FF;">[</span>a,b,c<span style="color: #0000FF;">]</span>,<span style="color: #0000FF;">[</span>1,2,3<span style="color: #0000FF;">]</span>,<span style="color: #BA36A5;">L</span>).
<span style="color: #BA36A5;">L</span> = <span style="color: #0000FF;">[</span>a, b, c, 1, 2, 3<span style="color: #0000FF;">]</span>.

?- append(<span style="color: #0000FF;">[</span>a,b,c<span style="color: #0000FF;">]</span>,<span style="color: #BA36A5;">L</span>,<span style="color: #0000FF;">[</span>a, b, c, 1, 2, 3<span style="color: #0000FF;">]</span>).
<span style="color: #BA36A5;">L</span> = <span style="color: #0000FF;">[</span>1, 2, 3<span style="color: #0000FF;">]</span>.

?- append(<span style="color: #BA36A5;">L1</span>, <span style="color: #BA36A5;">L2</span>, <span style="color: #0000FF;">[</span>a,b,c<span style="color: #0000FF;">]</span>).
<span style="color: #BA36A5;">L1</span> = <span style="color: #0000FF;">[]</span>,
<span style="color: #BA36A5;">L2</span> = <span style="color: #0000FF;">[</span>a, b, c<span style="color: #0000FF;">]</span> <span style="color: #0000FF;">;</span>
<span style="color: #BA36A5;">L1</span> = <span style="color: #0000FF;">[</span>a<span style="color: #0000FF;">]</span>,
<span style="color: #BA36A5;">L2</span> = <span style="color: #0000FF;">[</span>b, c<span style="color: #0000FF;">]</span> <span style="color: #0000FF;">;</span>
<span style="color: #BA36A5;">L1</span> = <span style="color: #0000FF;">[</span>a, b<span style="color: #0000FF;">]</span>,
<span style="color: #BA36A5;">L2</span> = <span style="color: #0000FF;">[</span>c<span style="color: #0000FF;">]</span> <span style="color: #0000FF;">;</span>
<span style="color: #BA36A5;">L1</span> = <span style="color: #0000FF;">[</span>a, b, c<span style="color: #0000FF;">]</span>,
<span style="color: #BA36A5;">L2</span> = <span style="color: #0000FF;">[]</span> <span style="color: #0000FF;">;</span>
false.
</pre>
</div></li>

</ul>
</section>
<section id="slide-org89852ad">
<h4 id="org89852ad"><code>maplist</code></h4>
<ul>
<li>Das Ziel <code>maplist(Pred_2, As, Bs)</code> ist genau dann wahr, wenn die
Anwendung des Prädikats <code>Pred_2(A, B)</code> für jedes Paar von Elementen
\(A\in As\) und \(B\in Bs\), die denselben Index haben, wahr ist.</li>
<li><code>maplist</code> ist ein Prädikat höherer Ordnung.</li>
<li><p>
Anwendungsbeispiel
</p>
<div class="org-src-container">

<pre  class="src src-prolog">?- plus(1,5,<span style="color: #BA36A5;">X</span>).
<span style="color: #BA36A5;">X</span> = 6.

?- maplist(plus(1), <span style="color: #0000FF;">[</span>3,4,5<span style="color: #0000FF;">]</span>, <span style="color: #BA36A5;">L</span>).
<span style="color: #BA36A5;">L</span> = <span style="color: #0000FF;">[</span>4, 5, 6<span style="color: #0000FF;">]</span>.

?- maplist(plus(<span style="color: #BA36A5;">X</span>), <span style="color: #0000FF;">[</span>3,4,5<span style="color: #0000FF;">]</span>, <span style="color: #0000FF;">[</span>5,6,7<span style="color: #0000FF;">]</span>).
<span style="color: #BA36A5;">X</span> = 2.

?- maplist(plus(<span style="color: #BA36A5;">X</span>), <span style="color: #0000FF;">[</span>3,4,5<span style="color: #0000FF;">]</span>, <span style="color: #0000FF;">[</span>5,6,6<span style="color: #0000FF;">]</span>).
false.
</pre>
</div></li>

</ul>

</section>
<section id="slide-orgef50f16">
<h3 id="orgef50f16">Negation, <code>cut</code> und <code>fail</code></h3>
<div class="outline-text-3" id="text-orgef50f16">
</div>
</section>
<section id="slide-org4e1830a">
<h4 id="org4e1830a">Erzwingen von Backtracking</h4>
<ul>
<li><p>
Gesucht ist ein Prädikat <code>all/1</code>, das angewendet auf eine Liste
alle Elemente anzeigt:
</p>
<div class="small">
<div class="org-src-container">

<pre  class="src src-prolog">?- all(<span style="color: #0000FF;">[</span>a,b,c<span style="color: #0000FF;">]</span>).
a
b
c
true.
</pre>
</div>

</div></li>

</ul>
</section>
<section id="slide-org8588bf1">
<h5 id="org8588bf1">Erste Versuche</h5>
<p>
Die Verwendung des Prädikats 
</p>
<pre class="example">
all_0(L) :- member(X,L).
</pre>

<p>
führt zu folgendem Ergebnis:
</p>
<div class="smaller">
<div class="org-src-container">

<pre  class="src src-prolog">?- all_0(<span style="color: #0000FF;">[</span>a,b,c<span style="color: #0000FF;">]</span>).
true <span style="color: #0000FF;">;</span>
true <span style="color: #0000FF;">;</span>
true <span style="color: #0000FF;">;</span>
false.
</pre>
</div>

</div>
<p>
Verwendung des Standardprädikats <code>write/1</code>:
</p>
<pre class="example">
all_1(L) :- member(X,L), write(X).
</pre>

<div class="small">
<div class="org-src-container">

<pre  class="src src-prolog">?- all_1(<span style="color: #0000FF;">[</span>a,b,c<span style="color: #0000FF;">]</span>).
a
true <span style="color: #0000FF;">;</span>
b
true <span style="color: #0000FF;">;</span>
c
true <span style="color: #0000FF;">;</span>
false.
</pre>
</div>

</div>
</section>
<section id="slide-orga49d0b5">
<h5 id="orga49d0b5">Verwendung von <code>fail/0</code></h5>
<ul>
<li>Das Prädikat fail/0 schlägt immer fehl.</li>
<li>Seine Verwendung führt daher immer zu Backtracking.</li>
<li><p>
Damit kann hier die Ausgabe aller Elemente ohne Benutzerinteraktion
erreicht werden:
</p>
<div class="smaller">
<div class="org-src-container">

<pre  class="src src-prolog"><span style="color: #006699;">all_2</span>(<span style="color: #BA36A5;">L</span>) :- member(<span style="color: #BA36A5;">X</span>,<span style="color: #BA36A5;">L</span>), write(<span style="color: #BA36A5;">X</span>),fail.
?- all_2(<span style="color: #0000FF;">[</span>a,b,c<span style="color: #0000FF;">]</span>).
abc
false.
</pre>
</div>

</div></li>
<li><p>
Beseitigung der „Schönheitsfehler“:
</p>
<div class="small">
<div class="org-src-container">

<pre  class="src src-prolog"><span style="color: #006699;">all</span>(<span style="color: #BA36A5;">L</span>):- member(<span style="color: #BA36A5;">X</span>,<span style="color: #BA36A5;">L</span>),writeln(<span style="color: #BA36A5;">X</span>),fail.
<span style="color: #006699;">all</span>(<span style="color: #BA36A5;">_</span>).

?- all(<span style="color: #0000FF;">[</span>a,b,c<span style="color: #0000FF;">]</span>).
a
b
c
true.
</pre>
</div>

</div></li>

</ul>

</section>
<section id="slide-org7266890">
<h4 id="org7266890">Das Standardprädikat <code>!/0</code> (Cut)</h4>
<p>
(vgl. <a href="http://www.learnprolognow.org/lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch10">Learn Prolog Now</a>)
</p>
<ul>
<li><p>
Gesucht ein Prädikat <code>max/3</code>, das drei ganze Zahlen als Argumente
erwartet und erfüllt ist, wenn das dritte Argument gleich dem
größeren der beiden ersten Argumente ist.
</p>
<div class="org-src-container">

<pre  class="src src-prolog"><span style="color: #006699;">max</span>(<span style="color: #BA36A5;">X</span>,<span style="color: #BA36A5;">Y</span>,<span style="color: #BA36A5;">Y</span>):- <span style="color: #BA36A5;">X</span> =&lt; <span style="color: #BA36A5;">Y</span>. 
<span style="color: #006699;">max</span>(<span style="color: #BA36A5;">X</span>,<span style="color: #BA36A5;">Y</span>,<span style="color: #BA36A5;">X</span>):- <span style="color: #BA36A5;">X</span> &gt;  <span style="color: #BA36A5;">Y</span>.

?- max(5,4,5).
true.

?- max(2,3,3).
true <span style="color: #0000FF;">;</span>
false.

?- max(5,4,4).
false.

?- max(5,4,<span style="color: #BA36A5;">X</span>).
<span style="color: #BA36A5;">X</span> = 5.

?- max(2,3,<span style="color: #BA36A5;">X</span>).
<span style="color: #BA36A5;">X</span> = 3 <span style="color: #0000FF;">;</span>
false.
</pre>
</div></li>
<li><code>max/3</code> ist korrekt, aber ineffizient, warum?</li>

</ul>
</section>
<section id="slide-orgcd9f94f">
<h5 id="orgcd9f94f">Vermeidung des Backtracking</h5>
<ul>
<li>Da die beiden Regeln von <code>max/3</code> sich gegenseitig ausschließen, wäre
es wünschenswert, das Backtracking für den Fall, dass die erste
Regel erfüllt ist, zu vermeiden, da die zweite nie erfüllt werden kann.</li>
<li><p>
Das ermöglicht der Cut-Operator <code>!/0</code>. 
</p>
<div class="org-src-container">

<pre  class="src src-prolog"><span style="color: #006699;">max</span>(<span style="color: #BA36A5;">X</span>,<span style="color: #BA36A5;">Y</span>,<span style="color: #BA36A5;">Y</span>):- <span style="color: #BA36A5;">X</span> =&lt; <span style="color: #BA36A5;">Y</span>, <span style="color: #0000FF;">!</span>. 
<span style="color: #006699;">max</span>(<span style="color: #BA36A5;">X</span>,<span style="color: #BA36A5;">Y</span>,<span style="color: #BA36A5;">X</span>):- <span style="color: #BA36A5;">X</span> &gt;  <span style="color: #BA36A5;">Y</span>.

?- max(2,3,3).
true.

?- max(5,4,<span style="color: #BA36A5;">X</span>).
<span style="color: #BA36A5;">X</span> = 5.

?- max(2,3,<span style="color: #BA36A5;">X</span>).
<span style="color: #BA36A5;">X</span> = 3.
</pre>
</div></li>

</ul>
</section>
<section id="slide-org954a47c">
<h5 id="org954a47c">Wirkungsweise und Nutzen des Cut-Operators</h5>
<ul>
<li>Wirkungsweise:
<ul>
<li>Der Cut wird im Rumpf von Regeln eingesetzt und verhindert Backtracking.</li>
<li>Der Cut gelingt immer.</li>
<li>Nach dem Passieren eines Cuts in einem Regelrumpf sind
<ul>
<li>die Teilziele, die in demselben Regelrumpf vor dem Cut stehen, und</li>
<li>alle weiteren Klauseln desselben Prädikats, die hinter der Regel
stehen, vom weiteren Backtracking ausgeschlossen.</li>

</ul></li>

</ul></li>
<li>Der Cut kann genutzt werden für
<ul>
<li>Effizienzsteigerung</li>
<li>Speichereinsparung</li>
<li>Verkürzung von Programmen</li>

</ul></li>

</ul>
</section>
<section id="slide-org60c4926">
<h5 id="org60c4926">Grüne und rote Cuts</h5>
<ul>
<li>Der Cut in <code>max/3</code> ändert nichts am Ergebnis des Prädikats gegenüber
der ersten Version ohne Cut. Einen solchen Cut nennt man grün.</li>
<li>Er dient hier der Effizienzsteigerung.</li>
<li><p>
Man könnte auf die Idee kommen, den Rumpf der zweiten Regel als
redundant zu betrachten und das Prädikat dann so schreiben:
</p>
<div class="smaller">
<div class="org-src-container">

<pre  class="src src-prolog"><span style="color: #006699;">max</span>(<span style="color: #BA36A5;">X</span>,<span style="color: #BA36A5;">Y</span>,<span style="color: #BA36A5;">Y</span>):- <span style="color: #BA36A5;">X</span> =&lt; <span style="color: #BA36A5;">Y</span>, <span style="color: #0000FF;">!</span>. 
<span style="color: #006699;">max</span>(<span style="color: #BA36A5;">X</span>,<span style="color: #BA36A5;">Y</span>,<span style="color: #BA36A5;">X</span>).
</pre>
</div>

</div></li>
<li>Anfragen der Art <code>max(5,4,X)</code> oder <code>max(2,3,X)</code> werden nach wie vor
korrekt beantwortet.</li>
<li>Die Anfrage <code>max(4,5,4)</code> müsste fehlschlagen, liefert aber <code>true</code>. Warum?</li>

</ul>
<ul class="fragment roll-in">
<li>Da <code>max(4,5,4)</code> nicht mit dem ersten Regelkopf unifizierbar ist,
geht Prolog direkt zur zweiten Klausel, die trivialerweise <code>true</code>
liefert.</li>

</ul>
</section>
<section>
<ul>
<li><p>
Schreibt man das Prädikat wie folgt um
</p>
<div class="smaller">
<div class="org-src-container">

<pre  class="src src-prolog"><span style="color: #006699;">max</span>(<span style="color: #BA36A5;">X</span>,<span style="color: #BA36A5;">Y</span>,<span style="color: #BA36A5;">Z</span>):- <span style="color: #BA36A5;">X</span> =&lt; <span style="color: #BA36A5;">Y</span>, <span style="color: #0000FF;">!</span>, <span style="color: #BA36A5;">Y</span> = <span style="color: #BA36A5;">Z</span>. 
<span style="color: #006699;">max</span>(<span style="color: #BA36A5;">X</span>,<span style="color: #BA36A5;">Y</span>,<span style="color: #BA36A5;">X</span>).  
</pre>
</div>

</div>
<p>
funktioniert wieder alles. Jetzt kann der erste Regelkopf mit
<code>max(4,5,4)</code> unifiziert werden.
</p></li>
<li>Diesen Cut nennt man rot, weil er nicht entfernt werden kann, ohne das Resultat zu
verändern.</li>

</ul>
<blockquote>
<p>
Fazit: Mit Cuts muss man vorsichtig umgehen.
</p>
</blockquote>
</section>
<section id="slide-org0a64f61">
<h4 id="org0a64f61">Negation mit Cut und <code>fail</code></h4>
<ul>
<li><p>
Keine Regel ohne Ausnahme: Wir wollen festhalten, dass Karl Pizza
mag, außer Salami-Pizza:
</p>
<div class="org-src-container">

<pre  class="src src-prolog"><span style="color: #006699;">mag</span>(karl, <span style="color: #BA36A5;">X</span>) :- salami_pizza(<span style="color: #BA36A5;">X</span>),<span style="color: #0000FF;">!</span>,fail.
<span style="color: #006699;">mag</span>(karl, <span style="color: #BA36A5;">X</span>) :- pizza(<span style="color: #BA36A5;">X</span>).

<span style="color: #006699;">pizza</span>(<span style="color: #BA36A5;">X</span>)  :-  vier_jahreszeiten_pizza(<span style="color: #BA36A5;">X</span>).
<span style="color: #006699;">pizza</span>(<span style="color: #BA36A5;">X</span>)  :-  salami_pizza(<span style="color: #BA36A5;">X</span>). 
<span style="color: #006699;">pizza</span>(<span style="color: #BA36A5;">X</span>)  :-  champignon_pizza(<span style="color: #BA36A5;">X</span>).

<span style="color: #006699;">vier_jahreszeiten_pizza</span>(vklein). 
<span style="color: #006699;">vier_jahreszeiten_pizza</span>(vgross). 
<span style="color: #006699;">salami_pizza</span>(s). 
<span style="color: #006699;">champignon_pizza</span>(c).

?- mag(karl,c).
true.

?- mag(karl,s).
false.
</pre>
</div></li>
<li>So weit, so gut aber &#x2026;</li>

</ul>
</section>
<section id="slide-orgeb97022">
<h5 id="orgeb97022">Wirkungsweise und Probleme &#x2026;</h5>
<ul>
<li>Wirkungsweise der ersten Regel: 
<ul>
<li>Wenn <code>X=s</code>, ist  <code>salami_pizza(X)</code>  erfüllt.</li>
<li>Wir erreichen den Cut, d.&nbsp;h. die zweite Regel wird nicht
probiert.</li>
<li>Anschließend fordert <code>fail</code> ein Backtracking, was aber vom Cut
verhindert wird.</li>
<li>Das Ergebnis von <code>mag(karl,s)</code> ist also <code>false</code>.</li>

</ul></li>
<li>Probleme
<ul>
<li>Die Regeln des Prädikats <code>mag</code> dürfen nicht vertauscht werden.</li>
<li>Der Cut ist rot.</li>
<li>Außerdem: <code>mag(karl, X)</code> liefert <code>false</code>.</li>

</ul></li>

</ul>
</section>
<section id="slide-org8311cad">
<h5 id="org8311cad">&#x2026; Abhilfe</h5>
<ul>
<li>Die Cut-fail-Kombination stellt eine Art Negation zur Verfügung, die
auch als <i>negation as failure</i> bezeichnet wird.</li>
<li><p>
Versteckt man diese in einem Prädikat <code>neg/1</code>, lässt sich das
<code>mag/1</code>-Prädikat sehr viel prägnanter aufschreiben:
</p>
<div class="smaller">
<div class="org-src-container">

<pre  class="src src-prolog"><span style="color: #006699;">neg</span>(<span style="color: #BA36A5;">Ziel</span>)  :-  <span style="color: #BA36A5;">Ziel</span>,<span style="color: #0000FF;">!</span>,fail. 
<span style="color: #006699;">neg</span>(<span style="color: #BA36A5;">Ziel</span>).

<span style="color: #006699;">mag</span>(karl, <span style="color: #BA36A5;">X</span>) :- pizza(<span style="color: #BA36A5;">X</span>), neg(salami_pizza(<span style="color: #BA36A5;">X</span>)).
</pre>
</div>

</div></li>
<li>Karl mag Pizza, aber keine Salami-Pizza.</li>
<li><p>
Statt <code>neg/1</code> kann auch das Standardprädikat <code>\+/1</code> verwendet
werden:
</p>
<pre class="example">
mag(karl, X) :- pizza(X), \+ (salami_pizza(X)).
</pre></li>
<li><p>
Die Frage <code>mag(karl, X)</code> liefert jetzt auch das richtige Ergebnis:
</p>
<div class="smaller">
<div class="org-src-container">

<pre  class="src src-prolog">?- mag(karl, <span style="color: #BA36A5;">X</span>).
<span style="color: #BA36A5;">X</span> = vklein <span style="color: #0000FF;">;</span>
<span style="color: #BA36A5;">X</span> = vgross <span style="color: #0000FF;">;</span>
<span style="color: #BA36A5;">X</span> = c.
</pre>
</div>

</div></li>

</ul>
</section>
<section id="slide-org5b71dff">
<h5 id="org5b71dff"><code>\+/1</code> ist keine logische Negation</h5>
<ul>
<li>Das <code>mag/1</code>-Prädikat ist auch in der letzten Fassung nicht
vollständig deklarativ.</li>
<li><p>
Schreibt man das Prädikat als
</p>
<pre class="example">
mag(karl, X) :- \+ (salami_pizza(X)), pizza(X).
</pre>

<p>
liefert <code>mag(karl, X)</code> wieder <code>false</code>.
</p></li>
<li>Man mache sich klar, woran das liegt.</li>

</ul>



</section>
</section>
<section>
<section id="slide-org141f016">
<h2 id="org141f016">Prolog &#x2026; und sonst?</h2>
<ul>
<li>Prolog ist zwar das Musterbeispiel für die logische Programmierung,
aber es gibt durchaus Alternativen.</li>

</ul>
</section>
<section id="slide-org1ec683e">
<h3 id="org1ec683e">miniKanren</h3>
<ul>
<li><i>miniKanren</i> ist eine domänenspezifische Sprache für die logische
Programmierung, die in verschiedenste Wirtssprache eingebettet
werden kann. Dazu gehören u.&nbsp;a.
<ul>
<li>Scheme, Racket</li>
<li>Haskell</li>
<li>Python</li>
<li>Ruby</li>
<li>Java, C#</li>
<li>Javascript</li>
<li>Clojure (hierzu gibt es weiter unten noch einen <a href="PP2-11-ConLogProgr.html#/slide-MissingReference">Exkurs</a>.)</li>

</ul></li>
<li>weitergehende Information im <a href="http://minikanren.org">Web</a>.</li>

</ul>
</section>
<section id="slide-orgbac1f30">
<h3 id="orgbac1f30">Z3</h3>
<ul>
<li><i>Z3</i> ist ein Theorembeweiser, der bei <a href="https://github.com/Z3Prover">Microsoft Research</a> entwickelt
wird</li>
<li>wird benutzt in Anwendungen aus den Bereichen
<ul>
<li>Software/Hardware-Verifikation</li>
<li>Constraint-Programmierung</li>
<li>Geometrische Problem</li>

</ul></li>
<li>basiert (im Gegensatz zu Prolog) auf der Prädikatenlogik</li>
<li>kann im <a href="https://rise4fun.com/z3/tutorial">Browser</a> interaktiv genutzt werden</li>
<li>recht gute Einführung ist <a href="https://funktionale-programmierung.de/2020/02/03/z3.html">hier</a> zu finden</li>
<li>wird meist in andere Programmiersprachen eingebettet, z.&nbsp;B. in <a href="https://ericpony.github.io/z3py-tutorial/guide-examples.htm">Python</a>.</li>

</ul>
</section>
</section>
<section>
<section id="slide-bibliography">
<h2 id="bibliography">Literaturverzeichnis</h2>
<ul class='org-ref-bib'><li><a id="Bramer2013">[Bramer2013] Max Bramer, Logic Programming with Prolog, Springer (2013).</a></li>
<li><a id="Clocksin2003">[Clocksin2003] William Clocksin & Christopher Mellish, Programming in Prolog: Using the ISO Standard, Springer (2003).</a></li>
</ul>
</section>
</section>
</div>
</div>
<script src="./reveal.js/js/reveal.js"></script>
<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: true,
center: true,
slideNumber: 'c',
rollingLinks: false,
keyboard: true,
mouseWheel: false,
fragmentInURL: true,
hashOneBasedIndex: false,
pdfSeparateFragments: true,

overview: true,
margin: 0.05,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'slide', // see README of reveal.js for options
transitionSpeed: 'default',

// Optional libraries used to extend reveal.js
dependencies: [
 { src: './reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: './reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: './reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
 { src: './reveal.js/plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } },
 { src: './reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } }]

,dependencies: [ { src: 'plugin/menu/menu.js', async: true }, { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true }, { src: 'reveal.js/plugin/search/search.js', async: true }] , menu: {hideMissingTitles: true}});
</script>
</body>
</html>
