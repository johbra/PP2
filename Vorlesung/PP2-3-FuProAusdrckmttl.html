<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="de" xml:lang="de">
<head>
<!-- 2019-11-10 Sun 23:31 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Ausdrucksmittel funktionaler Programmiersprachen</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Johannes Brauer" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="styles/bigblow/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="styles/bigblow/css/bigblow.css"/>
<link rel="stylesheet" type="text/css" href="styles/bigblow/css/hideshow.css"/>
<script type="text/javascript" src="styles/bigblow/js/jquery-1.11.0.min.js"></script>
<script type="text/javascript" src="styles/bigblow/js/jquery-ui-1.10.2.min.js"></script>
<script type="text/javascript" src="styles/bigblow/js/jquery.localscroll-min.js"></script>
<script type="text/javascript" src="styles/bigblow/js/jquery.scrollTo-1.4.3.1-min.js"></script>
<script type="text/javascript" src="styles/bigblow/js/jquery.zclip.min.js"></script>
<script type="text/javascript" src="styles/bigblow/js/bigblow.js"></script>
<script type="text/javascript" src="styles/bigblow/js/hideshow.js"></script>
<script type="text/javascript" src="styles/lib/js/jquery.stickytableheaders.min.js"></script>
<link rel="stylesheet" type="text/css" href="mycss/mystyle.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Ausdrucksmittel funktionaler Programmiersprachen
<br />
<span class="subtitle">Programmierparadigmen</span>
</h1>

<div id="outline-container-org52f0efa" class="outline-2">
<h2 id="org52f0efa">Ziele</h2>
<div class="outline-text-2" id="text-org52f0efa">
<ul class="org-ul">
<li>Kennen und Anwenden besonderer Ausdrucksmittel verschiedener funktionaler Sprachen:
<ul class="org-ul">
<li>Mustervergleich (pattern matching) in <i>SML</i></li>
<li>Typinferenz in <i>SML</i></li>
<li>Partielle Anwendung von Funktionen</li>
<li>Curryfizierung</li>
<li>Destructuring in <i>Clojure</i></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgde4af2b" class="outline-2">
<h2 id="orgde4af2b">Mustervergleich (pattern matching)</h2>
<div class="outline-text-2" id="text-orgde4af2b">
</div>
<div id="outline-container-org312c04e" class="outline-3">
<h3 id="org312c04e">Algebraische Datentypen</h3>
<div class="outline-text-3" id="text-org312c04e">
<p>
Im Modul <i>Einführung in die Programmierung</i> wurden algebraische
 Datentypen behandelt: Produkttypen und Summentypen.
</p>
</div>
<div id="outline-container-org70a60b6" class="outline-4">
<h4 id="org70a60b6">Produkttypen</h4>
<div class="outline-text-4" id="text-org70a60b6">
<ul class="org-ul">
<li>auch Verbünde, records genannt</li>
<li><p>
Die Menge aller Exemplare der Strukturdefinition
</p>
<pre class="example">
(define-struct point [x y]) 
</pre>

<p>
kann als Teilmenge des kartesischen Produkts 
\[number \times number\] angesehen werden.
</p></li>
</ul>
</div>
</div>
<div id="outline-container-org69111ea" class="outline-4">
<h4 id="org69111ea">Produkttypen in SML</h4>
<div class="outline-text-4" id="text-org69111ea">
<ul class="org-ul">
<li>Tupel (vgl. <a href="./PP2-2-PrgSprchnTypsstm.html#zusammengesetzte-typen-tupel">Zusammengesetzte Typen: Tupel</a>)
<ul class="org-ul">
<li>Komponentenzugriff über Indizes (by position)</li>
</ul></li>
<li>Verbünde (vgl. <a href="./PP2-2-PrgSprchnTypsstm.html#zusammengesetzte-typen-verbuende">Zusammengesetzte Typen: Verbünde</a>)
<ul class="org-ul">
<li>Komponentenzugriff über Feldbezeichner (by name)</li>
</ul></li>
<li><p>
Ein Punkt-Exemplar als Verbund:
</p>
<pre class="example">
{x=12, y=9}
</pre></li>
<li><p>
Deklaration eines Typbezeichners:
</p>
<pre class="example">
type point = { x : int, y: int }
</pre></li>
<li><p>
<code>type</code> definiert Typsynonyme:
</p>
<div class="small">
<div class="org-src-container">
<pre class="src src-sml">- <span style="color: #0000FF;">type</span> <span style="font-weight: bold;">point</span> = <span style="color: #707183;">{</span> x : int, y: int <span style="color: #707183;">}</span>;
<span style="color: #0000FF;">type</span> <span style="font-weight: bold;">point</span> = <span style="color: #707183;">{</span>x:int, y:int<span style="color: #707183;">}</span>
- <span style="color: #707183;">{</span>x=12, y=9<span style="color: #707183;">}</span>;
<span style="color: #0000FF;">val</span> <span style="color: #BA36A5;">it</span> = <span style="color: #707183;">{</span>x=12,y=9<span style="color: #707183;">}</span> : <span style="color: #707183;">{</span>x:int, y:int<span style="color: #707183;">}</span>
</pre>
</div>

</div></li>
</ul>
</div>
</div>
<div id="outline-container-orgc205b4a" class="outline-4">
<h4 id="orgc205b4a">Summentypen</h4>
<div class="outline-text-4" id="text-orgc205b4a">
<ul class="org-ul">
<li>in <i>Einführung in die Programmierung</i> als <i>gemischte Daten</i>
bezeichnet</li>
<li>Racket kennt keine Syntax für Summentypen.</li>
<li><p>
Beispiel aus EidP: Flächeninhalt von Figuren
</p>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">Eine Figur ist entweder</span>
<span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">- ein Rechteck oder</span>
<span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">- ein Kreis</span>
<span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">Name: shape</span>

<span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">Fl&#228;cheninhalt einer Figur berechnen</span>
<span style="color: #707183;">(</span>check-within <span style="color: #7388D6;">(</span>shape-area <span style="color: #909183;">(</span>make-circle 1.0<span style="color: #909183;">)</span><span style="color: #7388D6;">)</span> pi 0.01<span style="color: #707183;">)</span>
<span style="color: #707183;">(</span>check-within <span style="color: #7388D6;">(</span>shape-area <span style="color: #909183;">(</span>make-rectangle 2.5 3.0<span style="color: #909183;">)</span><span style="color: #7388D6;">)</span> 7.5 0.01<span style="color: #707183;">)</span>
<span style="color: #707183;">(</span><span style="color: #0000FF;">define</span> <span style="color: #006699;">shape-area</span>
  <span style="color: #7388D6;">(</span><span style="color: #0000FF;">lambda</span> <span style="color: #909183;">[</span>s<span style="color: #909183;">]</span>
    <span style="color: #909183;">(</span><span style="color: #0000FF;">cond</span>
      <span style="color: #709870;">[</span><span style="color: #907373;">(</span>circle? s<span style="color: #907373;">)</span>    <span style="color: #907373;">(</span>circle-area s<span style="color: #907373;">)</span><span style="color: #709870;">]</span>
      <span style="color: #709870;">[</span><span style="color: #907373;">(</span>rectangle? s<span style="color: #907373;">)</span> <span style="color: #907373;">(</span>rect-area s<span style="color: #907373;">)</span><span style="color: #709870;">]</span><span style="color: #909183;">)</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org0b5066c" class="outline-4">
<h4 id="org0b5066c">Summentypen in SML</h4>
<div class="outline-text-4" id="text-org0b5066c">
<ul class="org-ul">
<li><p>
Beispiel:
</p>
<div class="small">
<div class="org-src-container">
<pre class="src src-sml"><span style="color: #0000FF;">datatype</span> <span style="font-weight: bold;">mytype</span> = TwoInts <span style="color: #0000FF;">of</span> int * int
                | Str <span style="color: #0000FF;">of</span> string
                | Pizza
</pre>
</div>

</div></li>
<li>Datentyp <code>mytype</code> für „gemischte Daten“ mit drei Varianten</li>
<li>Drei Konstruktoren: <code>TwoInts</code>, <code>Str</code>, <code>Pizza</code></li>
<li>Konstruktoren dienen zwei Zwecken:
<ol class="org-ol">
<li>Er ist entweder eine Funktion für die Erzeugung von Werten des
neuen Typs, wenn die Variante eine Komponente besitzt (erkennbar
am Schlüsselwort <code>of</code>) oder er repräsentiert selbst einen Wert
dieses Typs (im Beispiel oben: <code>Pizza</code>).</li>
<li>Konstuktoren dienen für Fallunterscheidungen in
sog. <i>case-expressions</i>, d.&nbsp;h. für Mustervergleiche.</li>
</ol></li>
</ul>
</div>
<div id="outline-container-org4ff0d8c" class="outline-5">
<h5 id="org4ff0d8c">Zugriff auf <code>datatype</code>-Werte</h5>
<div class="outline-text-5" id="text-org4ff0d8c">
<ul class="org-ul">
<li><p>
ausschließlich durch Mustervergleich:
</p>
<div class="small">
<div class="org-src-container">
<pre class="src src-sml"><span style="color: #0000FF;">fun</span> <span style="color: #006699;">f</span> x = <span style="color: #8D8D84;">(* </span><span style="color: #8D8D84; font-style: italic;">f has type mytype-&gt;int </span><span style="color: #8D8D84;">*)</span> 
    <span style="color: #0000FF;">case</span> x <span style="color: #0000FF;">of</span>
        Pizza =&gt; 3
      | TwoInts<span style="color: #707183;">(</span>i1,i2<span style="color: #707183;">)</span> =&gt; i1 + i2
      | Str s =&gt; String.size s
</pre>
</div>

</div></li>
<li><code>case</code>-Ausdrücke stellen ausdrucksmächtigere Fallunterscheidungen
dar (verglichen mit <code>if-then-else</code> oder <code>cond</code>).</li>
<li>Zwei Teilausdrücke werden ausgewertet:
<ol class="org-ol">
<li>der Ausdruck zwischen <code>case</code> und <code>of</code> (hier: <code>x</code>)</li>
<li>der erste Ausdruck hinter <code>of</code>, dessen Muster (der Teil vor <code>=&gt;</code>)
zu dem Wert von <code>x</code> passt.
Beispiel: Wenn <code>TwoInts(7,9)</code> an <code>f</code> übergeben wird, wird der
zweite Zweig ausgewählt. <code>f</code> liefert in diesem Fall 16.</li>
</ol></li>
</ul>
<div class="small">
<div class="org-src-container">
<pre class="src src-sml"><span style="color: #0000FF;">fun</span> <span style="color: #006699;">f</span> x = <span style="color: #8D8D84;">(* </span><span style="color: #8D8D84; font-style: italic;">f has type mytype-&gt;int </span><span style="color: #8D8D84;">*)</span> 
    <span style="color: #0000FF;">case</span> x <span style="color: #0000FF;">of</span>
        Pizza =&gt; 3
      | TwoInts<span style="color: #707183;">(</span>i1,i2<span style="color: #707183;">)</span> =&gt; i1 + i2
      | Str s =&gt; String.size s
</pre>
</div>

</div>
<ul class="org-ul">
<li>Beachte: Da die Variante <code>TwoInts</code> aus zwei Integer-Werten besteht,
muss (vorläufig) das Muster zwei Variablen (hier <code>i1, i2</code>)
benutzen/deklarieren.</li>
<li>Jeder Zweig muss den gleichen Ergebnistyp besitzen.</li>
<li>Jeder Zweig hat die Form <code>muster =&gt; ausdruck</code>.</li>
<li>Die Zweige werden durch <code>|</code> voneinander getrennt.</li>
<li>Jedes Muster benutzt einen anderen Konstruktor.</li>
</ul>
</div>
</div>
<div id="outline-container-org3f96fb2" class="outline-5">
<h5 id="org3f96fb2">Übertragung des Figur-Beispiels aus Racket</h5>
<div class="outline-text-5" id="text-org3f96fb2">
<div class="org-src-container">
<pre class="src src-sml"><span style="color: #0000FF;">datatype</span> <span style="font-weight: bold;">shape</span> =
         Rectangle <span style="color: #0000FF;">of</span> real * real
         | Circle <span style="color: #0000FF;">of</span> real

<span style="color: #0000FF;">fun</span> <span style="color: #006699;">shape_area</span> s =
    <span style="color: #0000FF;">case</span> s <span style="color: #0000FF;">of</span>
        Rectangle<span style="color: #707183;">(</span>w, h<span style="color: #707183;">)</span> =&gt; w * h
      | Circle<span style="color: #707183;">(</span>r<span style="color: #707183;">)</span> =&gt; 3.14159 * r * r
                                       
<span style="color: #0000FF;">val</span> <span style="color: #BA36A5;">ra</span> = shape_area <span style="color: #707183;">(</span>Rectangle <span style="color: #7388D6;">(</span>3.0, 4.0<span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>
<span style="color: #0000FF;">val</span> <span style="color: #BA36A5;">ca</span> = shape_area <span style="color: #707183;">(</span>Circle 1.0<span style="color: #707183;">)</span>

<span style="color: #8D8D84;">(* </span><span style="color: #8D8D84; font-style: italic;">Repl:</span><span style="color: #8D8D84;">*)</span>
<span style="color: #0000FF;">datatype</span> <span style="font-weight: bold;">shape</span> = Circle <span style="color: #0000FF;">of</span> real | Rectangle <span style="color: #0000FF;">of</span> real * real
<span style="color: #0000FF;">val</span> <span style="color: #BA36A5;">shape_area</span> = <span style="color: #0000FF;">fn</span> : shape -&gt; real
<span style="color: #0000FF;">val</span> <span style="color: #BA36A5;">ra</span> = 12.0 : real
<span style="color: #0000FF;">val</span> <span style="color: #BA36A5;">ca</span> = 3.14159 : real
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orga0db1a0" class="outline-4">
<h4 id="orga0db1a0">Listen als rekursive algebraische Datentypen</h4>
<div class="outline-text-4" id="text-orga0db1a0">
</div>
<div id="outline-container-orgac36772" class="outline-5">
<h5 id="orgac36772">in Racket</h5>
<div class="outline-text-5" id="text-orgac36772">
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #8D8D84;">; </span><span style="color: #8D8D84; font-style: italic;">Eine Liste ist</span>
<span style="color: #8D8D84;">; </span><span style="color: #8D8D84; font-style: italic;">- die leere Liste oder</span>
<span style="color: #8D8D84;">; </span><span style="color: #8D8D84; font-style: italic;">- ein Paar</span>
<span style="color: #8D8D84;">; </span><span style="color: #8D8D84; font-style: italic;">Name: lst</span>

<span style="color: #8D8D84;">; </span><span style="color: #8D8D84; font-style: italic;">die leere Liste</span>
<span style="color: #707183;">(</span><span style="color: #0000FF;">define</span> <span style="color: #006699;">empt</span> 'empt<span style="color: #707183;">)</span>
<span style="color: #707183;">(</span><span style="color: #0000FF;">define</span> <span style="color: #006699;">empt?</span> <span style="color: #7388D6;">(</span><span style="color: #0000FF;">lambda</span> <span style="color: #909183;">[</span>l<span style="color: #909183;">]</span> <span style="color: #909183;">(</span>equal? l empt<span style="color: #909183;">)</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>

<span style="color: #8D8D84;">; </span><span style="color: #8D8D84; font-style: italic;">Ein Paar besteht aus</span>
<span style="color: #8D8D84;">; </span><span style="color: #8D8D84; font-style: italic;">- einem Wert</span>
<span style="color: #8D8D84;">; </span><span style="color: #8D8D84; font-style: italic;">- einer Liste</span>
<span style="color: #707183;">(</span>define-struct lst <span style="color: #7388D6;">[</span>fst rst<span style="color: #7388D6;">]</span><span style="color: #707183;">)</span>

<span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">ein paar Umbenennungen:</span>
<span style="color: #707183;">(</span><span style="color: #0000FF;">define</span> <span style="color: #006699;">cns</span> make-lst<span style="color: #707183;">)</span>
<span style="color: #707183;">(</span><span style="color: #0000FF;">define</span> <span style="color: #006699;">fst</span> lst-fst<span style="color: #707183;">)</span>
<span style="color: #707183;">(</span><span style="color: #0000FF;">define</span> <span style="color: #006699;">rst</span> lst-rst<span style="color: #707183;">)</span>

<span style="color: #707183;">(</span><span style="color: #0000FF;">define</span> <span style="color: #006699;">list-sum</span>
  <span style="color: #7388D6;">(</span><span style="color: #0000FF;">lambda</span> <span style="color: #909183;">(</span>lis<span style="color: #909183;">)</span>
    <span style="color: #909183;">(</span><span style="color: #0000FF;">cond</span>
      <span style="color: #709870;">[</span><span style="color: #907373;">(</span>empt? lis<span style="color: #907373;">)</span> 0<span style="color: #709870;">]</span>
      <span style="color: #709870;">[</span><span style="color: #907373;">(</span>lst? lis<span style="color: #907373;">)</span> 
       <span style="color: #907373;">(</span>+ <span style="color: #6276BA;">(</span>fst lis<span style="color: #6276BA;">)</span>
          <span style="color: #6276BA;">(</span>list-sum <span style="color: #858580;">(</span>rst lis<span style="color: #858580;">)</span><span style="color: #6276BA;">)</span><span style="color: #907373;">)</span><span style="color: #709870;">]</span><span style="color: #909183;">)</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>

<span style="color: #707183;">(</span>= 11 <span style="color: #7388D6;">(</span>list-sum <span style="color: #909183;">(</span>cns 1 <span style="color: #709870;">(</span>cns 7 <span style="color: #907373;">(</span>cns 3 empt<span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org756474b" class="outline-5">
<h5 id="org756474b">in SML</h5>
<div class="outline-text-5" id="text-org756474b">
<ul class="org-ul">
<li><code>datatype</code>-Definitionen dürfen rekursiv sein.</li>
<li>Man beachte die Nutzung des Mustervergleichs in den Funktionen.</li>
</ul>
<div class="org-src-container">
<pre class="src src-sml"><span style="color: #0000FF;">datatype</span> <span style="font-weight: bold;">my_int_list</span> = Empty
                     | Cons <span style="color: #0000FF;">of</span> int * my_int_list

<span style="color: #0000FF;">val</span> <span style="color: #BA36A5;">one_two_three</span> = Cons<span style="color: #707183;">(</span>1,Cons<span style="color: #7388D6;">(</span>2,Cons<span style="color: #909183;">(</span>3,Empty<span style="color: #909183;">)</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>

<span style="color: #0000FF;">fun</span> <span style="color: #006699;">append_mylist</span> <span style="color: #707183;">(</span>xs,ys<span style="color: #707183;">)</span> =
    <span style="color: #0000FF;">case</span> xs <span style="color: #0000FF;">of</span>
        Empty =&gt; ys
      | Cons<span style="color: #707183;">(</span>x,xs'<span style="color: #707183;">)</span> =&gt; Cons<span style="color: #707183;">(</span>x, append_mylist<span style="color: #7388D6;">(</span>xs',ys<span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgf8f2ab0" class="outline-4">
<h4 id="orgf8f2ab0">Mustervergleich für in SML eingebaute Listen</h4>
<div class="outline-text-4" id="text-orgf8f2ab0">
<ul class="org-ul">
<li><p>
Statt
</p>
<div class="small">
<div class="org-src-container">
<pre class="src src-sml"><span style="color: #0000FF;">fun</span> <span style="color: #006699;">sum_list</span> <span style="color: #707183;">(</span>xs : int list<span style="color: #707183;">)</span> =
    <span style="color: #0000FF;">if</span> null xs
    <span style="color: #0000FF;">then</span> 0
    <span style="color: #0000FF;">else</span> hd<span style="color: #707183;">(</span>xs<span style="color: #707183;">)</span> + sum_list<span style="color: #707183;">(</span>tl xs<span style="color: #707183;">)</span>
</pre>
</div>

</div></li>
<li><p>
besser
</p>
<div class="small">
<div class="org-src-container">
<pre class="src src-sml"><span style="color: #0000FF;">fun</span> <span style="color: #006699;">sum_list</span> xs =
    <span style="color: #0000FF;">case</span> xs <span style="color: #0000FF;">of</span>
        <span style="color: #707183;">[]</span> =&gt; 0
      | x::xs&#8217; =&gt; x + sum_list xs&#8217;
</pre>
</div>

</div></li>
</ul>
</div>
</div>
<div id="outline-container-org78483f8" class="outline-4">
<h4 id="org78483f8">Vorteile des Mustervergleichs</h4>
<div class="outline-text-4" id="text-org78483f8">
<ul class="org-ul">
<li>Laufzeitfehler wie durch <code>hd []</code> werden vermieden.</li>
<li>Wenn in einem <code>case</code>-Ausdruck eine Variante fehlt, erzeugt der
Compiler eine Warnung. Zur Laufzeit erzeugte eine fehlende Variante
einen Programmabbruch.</li>
<li>Falls eine Variante mehr als einmal verwendet wird, gibt der
Compiler ebenfalls eine Warnung.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgfdfc6f3" class="outline-3">
<h3 id="orgfdfc6f3">Polymorphe Datentypen</h3>
<div class="outline-text-3" id="text-orgfdfc6f3">
<ul class="org-ul">
<li><p>
die <code>append</code> Funktion für eingebaute Listen:
</p>
<div class="small">
<div class="org-src-container">
<pre class="src src-sml"><span style="color: #0000FF;">fun</span> <span style="color: #006699;">append</span> <span style="color: #707183;">(</span>xs,ys<span style="color: #707183;">)</span> =
    <span style="color: #0000FF;">case</span> xs <span style="color: #0000FF;">of</span>
        <span style="color: #707183;">[]</span> =&gt; ys
      | x :: xs' =&gt; x :: append<span style="color: #707183;">(</span>xs',ys<span style="color: #707183;">)</span>

<span style="color: #0000FF;">val</span> <span style="color: #BA36A5;">append</span> = <span style="color: #0000FF;">fn</span> : 'a list * 'a list -&gt; 'a list
</pre>
</div>

</div></li>
<li>Der eingebaute Listentyp ist polymorph (erkennbar am Typparameter
<code>'a</code>).</li>
<li>Polymorphe Datentypen erlauben generische Funktionen in statisch
getypten Sprachen.</li>
<li>Polymorph heißt <b>nicht</b> heterogen.</li>
</ul>
</div>

<div id="outline-container-org1529d3b" class="outline-4">
<h4 id="org1529d3b">Selbsdefinierte polymorphe Datentypen</h4>
<div class="outline-text-4" id="text-org1529d3b">
<ul class="org-ul">
<li><p>
Beispiel: Binärbaum, dessen interne Knoten Daten vom Typ <code>’a</code> und
dessen Blätter Daten vom Typ <code>’b</code> enthalten:
</p>
<pre class="example">
datatype (’a,’b) tree = Node of ’a * (’a,’b) tree * (’a,’b) tree 
                      | Leaf of ’b
</pre></li>
<li>Damit sind Konkretisierungen wie <code>(int,int) tree</code> oder
<code>(string,bool) tree</code> möglich.</li>
<li>Die Art der Verwendung von Konstruktoren und die Nutzung des
Mustervergleichs ist dieselbe für polymorphe und reguläre Datentypen.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org94e86f3" class="outline-3">
<h3 id="org94e86f3">Mustervergleich für Produkttypen und die Wahrheit über Funktionen</h3>
<div class="outline-text-3" id="text-org94e86f3">
<ul class="org-ul">
<li>Grundsätzlich ist der Mustervergleich auch auf Produkttypen anwendbar.</li>
<li>Für ein Record der Form <code>{f1=v1,...,fn=vn}</code> werden durch das Muster
<code>{f1=x1,...,fn=xn}</code> die Variablen <code>xi</code> an die Werte <code>vi</code> gebunden.</li>
<li>Ein Muster der Form <code>(x1,...,xn)</code> bindet die Werte eines Tupels
<code>(v1,...,vn)</code>, da die Schreibweise  <code>(x1,...,xn)</code> nur syntaktischer
Zucker für das Record <code>{1=x1,...,n=xn}</code> ist.</li>
<li><p>
Beispiel: Funktion, die die Elemente eines Tripels <code>int * int * int</code>
summiert: 
</p>
<div class="small">
<div class="org-src-container">
<pre class="src src-sml"><span style="color: #0000FF;">fun</span> <span style="color: #006699;">sum_triple</span> <span style="color: #707183;">(</span>triple : int * int * int<span style="color: #707183;">)</span> =
    <span style="color: #0000FF;">case</span> triple <span style="color: #0000FF;">of</span>
        <span style="color: #707183;">(</span>x,y,z<span style="color: #707183;">)</span> =&gt; z + y + x
</pre>
</div>

</div></li>
</ul>
</div>
<div id="outline-container-orgcf29e49" class="outline-4">
<h4 id="orgcf29e49">Andere (bessere) syntaktische Varianten</h4>
<div class="outline-text-4" id="text-orgcf29e49">
<div class="small">
<div class="org-src-container">
<pre class="src src-sml"><span style="color: #0000FF;">fun</span> <span style="color: #006699;">sum_triple</span> <span style="color: #707183;">(</span>triple : int*int*int<span style="color: #707183;">)</span> =
    <span style="color: #0000FF;">let</span> <span style="color: #0000FF;">val</span> <span style="color: #707183;">(</span>x,y,z<span style="color: #707183;">)</span> = triple
    <span style="color: #0000FF;">in</span> x+y+z <span style="color: #0000FF;">end</span>

<span style="color: #0000FF;">fun</span> <span style="color: #006699;">sum_triple</span> <span style="color: #707183;">(</span>x,y,z<span style="color: #707183;">)</span> = x+y+z
</pre>
</div>

</div>
<ul class="org-ul">
<li>Die letzte Variante akzeptiert ein Tripel als Argument und bindet
die Komponenten an die Variablen <code>x</code>, <code>y</code> und <code>z</code>.</li>
<li>Diese Form unterscheidet sich nicht von der bisherigen Notation für
Funktionen mit mehreren (hier drei) Parametern.</li>
<li>Mit anderen Worten:</li>
</ul>
<blockquote>
<p>
Jede Funktion in ML besitzt nur <b>einen</b> Parameter.
</p>
</blockquote>
</div>
</div>
</div>
<div id="outline-container-orgd51871e" class="outline-3">
<h3 id="orgd51871e">Geschachtelte Muster</h3>
<div class="outline-text-3" id="text-orgd51871e">
<div class="org-src-container">
<pre class="src src-sml"><span style="color: #0000FF;">exception</span> BadTriple
              
<span style="color: #0000FF;">fun</span> <span style="color: #006699;">zip3</span> list_triple =
    <span style="color: #0000FF;">case</span> list_triple <span style="color: #0000FF;">of</span>
        <span style="color: #707183;">(</span><span style="color: #7388D6;">[]</span>,<span style="color: #7388D6;">[]</span>,<span style="color: #7388D6;">[]</span><span style="color: #707183;">)</span> =&gt; <span style="color: #707183;">[]</span>
      | <span style="color: #707183;">(</span>hd1::tl1,hd2::tl2,hd3::tl3<span style="color: #707183;">)</span> =&gt; <span style="color: #707183;">(</span>hd1,hd2,hd3<span style="color: #707183;">)</span>::zip3<span style="color: #707183;">(</span>tl1,tl2,tl3<span style="color: #707183;">)</span>
      | _ =&gt; <span style="color: #0000FF;">raise</span> BadTriple

<span style="color: #0000FF;">fun</span> <span style="color: #006699;">unzip3</span> lst =
    <span style="color: #0000FF;">case</span> lst <span style="color: #0000FF;">of</span>
        <span style="color: #707183;">[]</span> =&gt; <span style="color: #707183;">(</span><span style="color: #7388D6;">[]</span>,<span style="color: #7388D6;">[]</span>,<span style="color: #7388D6;">[]</span><span style="color: #707183;">)</span>
      | <span style="color: #707183;">(</span>a,b,c<span style="color: #707183;">)</span>::tl =&gt; <span style="color: #0000FF;">let</span> <span style="color: #0000FF;">val</span> <span style="color: #707183;">(</span>l1,l2,l3<span style="color: #707183;">)</span> = unzip3 tl
                       <span style="color: #0000FF;">in</span>
                           <span style="color: #707183;">(</span>a::l1,b::l2,c::l3<span style="color: #707183;">)</span>
                       <span style="color: #0000FF;">end</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org5b59f27" class="outline-3">
<h3 id="org5b59f27">Exkurs: Destructuring in Clojure</h3>
<div class="outline-text-3" id="text-org5b59f27">
<p>
Unter <i>destructuring</i> versteht man eine Weise, Werte aus einer
Datenstruktur zu extrahieren und dabei an Variablen zu binden. Dabei
muss die Datenstruktur nicht traversiert werden. Destructuring wird
vorwiegend auf Vektoren und Maps angewendet, ist aber auch für Listen
und Zeichenketten möglich.
</p>

<p>
(vgl. <a href="https://clojure.org/guides/destructuring">Destructuring in Clojure</a>)
</p>
</div>
<div id="outline-container-org86f3255" class="outline-4">
<h4 id="org86f3255">Vektoren</h4>
<div class="outline-text-4" id="text-org86f3255">
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #0000FF;">def</span> <span style="color: #BA36A5;">my-vector</span> <span style="color: #7388D6;">[</span><span style="color: #D0372D;">:a</span> <span style="color: #D0372D;">:b</span> <span style="color: #D0372D;">:c</span> <span style="color: #D0372D;">:d</span><span style="color: #7388D6;">]</span><span style="color: #707183;">)</span>
<span style="color: #707183;">(</span><span style="color: #0000FF;">def</span> <span style="color: #BA36A5;">my-nested-vector</span> <span style="color: #7388D6;">[</span><span style="color: #D0372D;">:a</span> <span style="color: #D0372D;">:b</span> <span style="color: #D0372D;">:c</span> <span style="color: #D0372D;">:d</span> <span style="color: #909183;">[</span><span style="color: #D0372D;">:x</span> <span style="color: #D0372D;">:y</span> <span style="color: #D0372D;">:z</span><span style="color: #909183;">]</span><span style="color: #7388D6;">]</span><span style="color: #707183;">)</span>

<span style="color: #707183;">(</span><span style="color: #0000FF;">let</span> <span style="color: #7388D6;">[</span><span style="color: #909183;">[</span>a b c d<span style="color: #909183;">]</span> my-vector<span style="color: #7388D6;">]</span>
  <span style="color: #7388D6;">(</span><span style="color: #006FE0;">println</span> a b c d<span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>
<span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">=&gt; :a :b :c :d</span>

<span style="color: #707183;">(</span><span style="color: #0000FF;">let</span> <span style="color: #7388D6;">[</span><span style="color: #909183;">[</span>a _ _ d <span style="color: #709870;">[</span>x y z<span style="color: #709870;">]</span><span style="color: #909183;">]</span> my-nested-vector<span style="color: #7388D6;">]</span>
  <span style="color: #7388D6;">(</span><span style="color: #006FE0;">println</span> a d x y z<span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>
<span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">=&gt; :a :d :x :y :z</span>

<span style="color: #8D8D84;">;;; </span><span style="color: #8D8D84; font-style: italic;">Das Muster muss nicht den ganzen Vektor abdecken:</span>

<span style="color: #707183;">(</span><span style="color: #0000FF;">let</span> <span style="color: #7388D6;">[</span><span style="color: #909183;">[</span>a b c<span style="color: #909183;">]</span> my-vector<span style="color: #7388D6;">]</span>
  <span style="color: #7388D6;">(</span><span style="color: #006FE0;">println</span> a b c<span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>
<span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">=&gt; :a :b :c</span>
<span style="color: #8D8D84;">;;; </span><span style="color: #8D8D84; font-style: italic;">...</span>

<span style="color: #8D8D84;">;;; </span><span style="color: #8D8D84; font-style: italic;">Mit &amp; the-rest kann der restliche Teil des Vektors an the-rest gebunden werden</span>

<span style="color: #707183;">(</span><span style="color: #0000FF;">let</span> <span style="color: #7388D6;">[</span><span style="color: #909183;">[</span>a b &amp; the-rest<span style="color: #909183;">]</span> my-vector<span style="color: #7388D6;">]</span>
  <span style="color: #7388D6;">(</span><span style="color: #006FE0;">println</span> a b the-rest<span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>
<span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">=&gt; :a :b (:c :d)</span>

<span style="color: #8D8D84;">;;; </span><span style="color: #8D8D84; font-style: italic;">Wenn das Muster mehr Elemente "verlangt" als im Vektor vorhanden", werden die</span>
<span style="color: #8D8D84;">;;; </span><span style="color: #8D8D84; font-style: italic;">&#252;bersch&#252;ssigen Symbole an nil gebunden.</span>

<span style="color: #707183;">(</span><span style="color: #0000FF;">let</span> <span style="color: #7388D6;">[</span><span style="color: #909183;">[</span>a b c d e f g<span style="color: #909183;">]</span> my-vector<span style="color: #7388D6;">]</span>
  <span style="color: #7388D6;">(</span><span style="color: #006FE0;">println</span> a b c d e f g<span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>
<span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">=&gt; :a :b :c :d nil nil nil</span>

<span style="color: #8D8D84;">;;; </span><span style="color: #8D8D84; font-style: italic;">Mit :as some-symbol als die beiden letzten Eintr&#228;ge im Muster wird der ganze Vektor</span>
<span style="color: #8D8D84;">;;; </span><span style="color: #8D8D84; font-style: italic;">an some-symbol gebunden</span>

<span style="color: #707183;">(</span><span style="color: #0000FF;">let</span> <span style="color: #7388D6;">[</span><span style="color: #909183;">[</span><span style="color: #D0372D;">:as</span> all<span style="color: #909183;">]</span> my-vector<span style="color: #7388D6;">]</span>
  <span style="color: #7388D6;">(</span><span style="color: #006FE0;">println</span> all<span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>
<span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">=&gt; [:a :b :c :d]</span>

<span style="color: #707183;">(</span><span style="color: #0000FF;">let</span> <span style="color: #7388D6;">[</span><span style="color: #909183;">[</span>a <span style="color: #D0372D;">:as</span> all<span style="color: #909183;">]</span> my-vector<span style="color: #7388D6;">]</span>
  <span style="color: #7388D6;">(</span><span style="color: #006FE0;">println</span> a all<span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>
<span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">=&gt; :a [:a :b :c :d]</span>

<span style="color: #707183;">(</span><span style="color: #0000FF;">let</span> <span style="color: #7388D6;">[</span><span style="color: #909183;">[</span>a _ _ _ <span style="color: #709870;">[</span>x y z <span style="color: #D0372D;">:as</span> nested<span style="color: #709870;">]</span> <span style="color: #D0372D;">:as</span> all<span style="color: #909183;">]</span> my-nested-vector<span style="color: #7388D6;">]</span>
  <span style="color: #7388D6;">(</span><span style="color: #006FE0;">println</span> a x y z nested all<span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>
<span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">=&gt; :a :x :y :z [:x :y :z] [:a :b :c :d [:x :y :z]]</span>

<span style="color: #8D8D84;">;;; </span><span style="color: #8D8D84; font-style: italic;">&amp; the-rest und :as some-symbol k&#246;nnen auch zusammen benutzt werden.</span>

<span style="color: #707183;">(</span><span style="color: #0000FF;">let</span> <span style="color: #7388D6;">[</span><span style="color: #909183;">[</span>a b &amp; the-rest <span style="color: #D0372D;">:as</span> all<span style="color: #909183;">]</span> my-vector<span style="color: #7388D6;">]</span>
  <span style="color: #7388D6;">(</span><span style="color: #006FE0;">println</span> a b the-rest all<span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>
<span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">=&gt; :a :b (:c :d) [:a :b :c :d]</span>
</pre>
</div>
</div>
<div id="outline-container-orgaa1ff04" class="outline-5">
<h5 id="orgaa1ff04">Beispiel ohne Destructuring &#x2026;</h5>
<div class="outline-text-5" id="text-orgaa1ff04">
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #0000FF;">def</span> <span style="color: #BA36A5;">my-line</span> <span style="color: #7388D6;">[</span><span style="color: #909183;">[</span>5 10<span style="color: #909183;">]</span> <span style="color: #909183;">[</span>10 20<span style="color: #909183;">]</span><span style="color: #7388D6;">]</span><span style="color: #707183;">)</span>

<span style="color: #707183;">(</span><span style="color: #0000FF;">let</span> <span style="color: #7388D6;">[</span>p1 <span style="color: #909183;">(</span><span style="color: #006FE0;">first</span> my-line<span style="color: #909183;">)</span>
      p2 <span style="color: #909183;">(</span><span style="color: #006FE0;">second</span> my-line<span style="color: #909183;">)</span>
      x1 <span style="color: #909183;">(</span><span style="color: #006FE0;">first</span> p1<span style="color: #909183;">)</span>
      y1 <span style="color: #909183;">(</span><span style="color: #006FE0;">second</span> p1<span style="color: #909183;">)</span>
      x2 <span style="color: #909183;">(</span><span style="color: #006FE0;">first</span> p2<span style="color: #909183;">)</span>
      y2 <span style="color: #909183;">(</span><span style="color: #006FE0;">second</span> p2<span style="color: #909183;">)</span><span style="color: #7388D6;">]</span>
  <span style="color: #7388D6;">(</span><span style="color: #006FE0;">println</span> <span style="color: #008000;">"Line from ("</span> x1 <span style="color: #008000;">","</span> y1 <span style="color: #008000;">") to ("</span> x2 <span style="color: #008000;">", "</span> y2 <span style="color: #008000;">")"</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>
<span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">=&gt; "Line from ( 5 , 10 ) to ( 10 , 20 )"</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgd54aaf6" class="outline-5">
<h5 id="orgd54aaf6">&#x2026; und mit Destructuring</h5>
<div class="outline-text-5" id="text-orgd54aaf6">
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #0000FF;">def</span> <span style="color: #BA36A5;">my-line</span> <span style="color: #7388D6;">[</span><span style="color: #909183;">[</span>5 10<span style="color: #909183;">]</span> <span style="color: #909183;">[</span>10 20<span style="color: #909183;">]</span><span style="color: #7388D6;">]</span><span style="color: #707183;">)</span>

<span style="color: #707183;">(</span><span style="color: #0000FF;">let</span> <span style="color: #7388D6;">[</span><span style="color: #909183;">[</span>p1 p2<span style="color: #909183;">]</span> my-line
      <span style="color: #909183;">[</span>x1 y1<span style="color: #909183;">]</span> p1
      <span style="color: #909183;">[</span>x2 y2<span style="color: #909183;">]</span> p2<span style="color: #7388D6;">]</span>
 <span style="color: #7388D6;">(</span><span style="color: #006FE0;">println</span> <span style="color: #008000;">"Line from ("</span> x1 <span style="color: #008000;">","</span> y1 <span style="color: #008000;">") to ("</span> x2 <span style="color: #008000;">", "</span> y2 <span style="color: #008000;">")"</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>
<span style="color: #8D8D84;">;</span><span style="color: #8D8D84; font-style: italic;">= "Line from ( 5 , 10 ) to ( 10 , 20 )"</span>
<span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">=&gt; "Line from ( 5 , 10 ) to ( 10 , 20 )"</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orge07b698" class="outline-4">
<h4 id="orge07b698">Maps</h4>
<div class="outline-text-4" id="text-orge07b698">
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #0000FF;">def</span> <span style="color: #BA36A5;">my-hashmap</span> <span style="color: #7388D6;">{</span><span style="color: #D0372D;">:a</span> <span style="color: #008000;">"A"</span> <span style="color: #D0372D;">:b</span> <span style="color: #008000;">"B"</span> <span style="color: #D0372D;">:c</span> <span style="color: #008000;">"C"</span> <span style="color: #D0372D;">:d</span> <span style="color: #008000;">"D"</span><span style="color: #7388D6;">}</span><span style="color: #707183;">)</span>
<span style="color: #707183;">(</span><span style="color: #0000FF;">def</span> <span style="color: #BA36A5;">my-nested-hashmap</span> <span style="color: #7388D6;">{</span><span style="color: #D0372D;">:a</span> <span style="color: #008000;">"A"</span> <span style="color: #D0372D;">:b</span> <span style="color: #008000;">"B"</span> <span style="color: #D0372D;">:c</span> <span style="color: #008000;">"C"</span> <span style="color: #D0372D;">:d</span> <span style="color: #008000;">"D"</span> <span style="color: #D0372D;">:q</span> <span style="color: #909183;">{</span><span style="color: #D0372D;">:x</span> <span style="color: #008000;">"X"</span> <span style="color: #D0372D;">:y</span> <span style="color: #008000;">"Y"</span> <span style="color: #D0372D;">:z</span> <span style="color: #008000;">"Z"</span><span style="color: #909183;">}</span><span style="color: #7388D6;">}</span><span style="color: #707183;">)</span>

<span style="color: #707183;">(</span><span style="color: #0000FF;">let</span> <span style="color: #7388D6;">[</span><span style="color: #909183;">{</span>a <span style="color: #D0372D;">:a</span> d <span style="color: #D0372D;">:d</span><span style="color: #909183;">}</span> my-hashmap<span style="color: #7388D6;">]</span>
  <span style="color: #7388D6;">(</span><span style="color: #006FE0;">println</span> a d<span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>
<span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">=&gt; A D</span>

<span style="color: #707183;">(</span><span style="color: #0000FF;">let</span> <span style="color: #7388D6;">[</span><span style="color: #909183;">{</span>a <span style="color: #D0372D;">:a</span>, b <span style="color: #D0372D;">:b</span>, <span style="color: #709870;">{</span>x <span style="color: #D0372D;">:x</span>, y <span style="color: #D0372D;">:y</span><span style="color: #709870;">}</span> <span style="color: #D0372D;">:q</span><span style="color: #909183;">}</span> my-nested-hashmap<span style="color: #7388D6;">]</span>
  <span style="color: #7388D6;">(</span><span style="color: #006FE0;">println</span> a b x y<span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>
<span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">=&gt; A B X Y</span>

<span style="color: #8D8D84;">;;; </span><span style="color: #8D8D84; font-style: italic;">Wenn ein Schl&#252;ssel in der Map nicht existiert, wird die Variable an nil gebunden.</span>

<span style="color: #707183;">(</span><span style="color: #0000FF;">let</span> <span style="color: #7388D6;">[</span><span style="color: #909183;">{</span>a <span style="color: #D0372D;">:a</span>, not-found <span style="color: #D0372D;">:not-found</span>, b <span style="color: #D0372D;">:b</span><span style="color: #909183;">}</span> my-hashmap<span style="color: #7388D6;">]</span>
  <span style="color: #7388D6;">(</span><span style="color: #006FE0;">println</span> a not-found b<span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>
<span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">=&gt; A nil B</span>
<span style="color: #8D8D84;">;;; </span><span style="color: #8D8D84; font-style: italic;">...</span>

<span style="color: #8D8D84;">;;; </span><span style="color: #8D8D84; font-style: italic;">F&#252;r fehlende Schl&#252;ssel kann hinter dem Schl&#252;sselwort :or eine Map mit Default-Werten</span>
<span style="color: #8D8D84;">;;; </span><span style="color: #8D8D84; font-style: italic;">angegeben werden.</span>

<span style="color: #707183;">(</span><span style="color: #0000FF;">let</span> <span style="color: #7388D6;">[</span><span style="color: #909183;">{</span>a <span style="color: #D0372D;">:a</span>, not-found <span style="color: #D0372D;">:not-found</span>, b <span style="color: #D0372D;">:b</span>, <span style="color: #D0372D;">:or</span> <span style="color: #709870;">{</span>not-found <span style="color: #008000;">":)"</span><span style="color: #709870;">}</span><span style="color: #909183;">}</span> my-hashmap<span style="color: #7388D6;">]</span>
  <span style="color: #7388D6;">(</span><span style="color: #006FE0;">println</span> a not-found b<span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>
<span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">=&gt; A :) B</span>

<span style="color: #8D8D84;">;;; </span><span style="color: #8D8D84; font-style: italic;">Die Form :as some-symbol ist auch f&#252;r Maps verf&#252;gbar. </span>

<span style="color: #707183;">(</span><span style="color: #0000FF;">let</span> <span style="color: #7388D6;">[</span><span style="color: #909183;">{</span>a <span style="color: #D0372D;">:a</span>, b <span style="color: #D0372D;">:b</span>, <span style="color: #D0372D;">:as</span> all<span style="color: #909183;">}</span> my-hashmap<span style="color: #7388D6;">]</span>
  <span style="color: #7388D6;">(</span><span style="color: #006FE0;">println</span> a b all<span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>
<span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">=&gt; A B {:a A :b B :c C :d D}</span>

<span style="color: #8D8D84;">;;; </span><span style="color: #8D8D84; font-style: italic;">Die Kombination von :as und :or ist auch m&#246;glich.</span>

<span style="color: #707183;">(</span><span style="color: #0000FF;">let</span> <span style="color: #7388D6;">[</span><span style="color: #909183;">{</span>a <span style="color: #D0372D;">:a</span>, b <span style="color: #D0372D;">:b</span>, not-found <span style="color: #D0372D;">:not-found</span>, <span style="color: #D0372D;">:or</span> <span style="color: #709870;">{</span>not-found <span style="color: #008000;">":)"</span><span style="color: #709870;">}</span>, <span style="color: #D0372D;">:as</span> all<span style="color: #909183;">}</span> my-hashmap<span style="color: #7388D6;">]</span>
  <span style="color: #7388D6;">(</span><span style="color: #006FE0;">println</span> a b not-found all<span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>
<span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">=&gt; A B :) {:a A :b B :c C :d D}</span>
</pre>
</div>
</div>
<div id="outline-container-org7c32249" class="outline-5">
<h5 id="org7c32249">Beispiel</h5>
<div class="outline-text-5" id="text-org7c32249">
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #0000FF;">def</span> <span style="color: #BA36A5;">client</span> <span style="color: #7388D6;">{</span><span style="color: #D0372D;">:name</span> <span style="color: #008000;">"Super Co."</span>
             <span style="color: #D0372D;">:location</span> <span style="color: #008000;">"Philadelphia"</span>
             <span style="color: #D0372D;">:description</span> <span style="color: #008000;">"The worldwide leader in plastic tableware."</span><span style="color: #7388D6;">}</span><span style="color: #707183;">)</span>

<span style="color: #8D8D84;">;;; </span><span style="color: #8D8D84; font-style: italic;">ohne Destructuring</span>
<span style="color: #8D8D84;">;;;;;;;;;;;;;;;;;;;;;;</span>
<span style="color: #707183;">(</span><span style="color: #0000FF;">let</span> <span style="color: #7388D6;">[</span>name <span style="color: #909183;">(</span><span style="color: #D0372D;">:name</span> client<span style="color: #909183;">)</span>
      location <span style="color: #909183;">(</span><span style="color: #D0372D;">:location</span> client<span style="color: #909183;">)</span>
      description <span style="color: #909183;">(</span><span style="color: #D0372D;">:description</span> client<span style="color: #909183;">)</span><span style="color: #7388D6;">]</span>
  <span style="color: #7388D6;">(</span><span style="color: #006FE0;">println</span> name location <span style="color: #008000;">"-"</span> description<span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>
<span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">=&gt; Super Co. Philadelphia - The worldwide leader in plastic tableware.</span>

<span style="color: #8D8D84;">;;; </span><span style="color: #8D8D84; font-style: italic;">mit Destructuring</span>
<span style="color: #8D8D84;">;;;;;;;;;;;;;;;;;;;;;;</span>
 <span style="color: #707183;">(</span><span style="color: #0000FF;">let</span> <span style="color: #7388D6;">[</span><span style="color: #909183;">{</span>name <span style="color: #D0372D;">:name</span>
       location <span style="color: #D0372D;">:location</span>
       description <span style="color: #D0372D;">:description</span><span style="color: #909183;">}</span> client<span style="color: #7388D6;">]</span>
  <span style="color: #7388D6;">(</span><span style="color: #006FE0;">println</span> name location <span style="color: #008000;">"-"</span> description<span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>
<span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">=&gt; Super Co. Philadelphia - The worldwide leader in plastic tableware.</span>

<span style="color: #8D8D84;">;;; </span><span style="color: #8D8D84; font-style: italic;">und noch k&#252;rzer mit dem :keys Schl&#252;sselwort</span>
<span style="color: #8D8D84;">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span style="color: #707183;">(</span><span style="color: #0000FF;">let</span> <span style="color: #7388D6;">[</span><span style="color: #909183;">{</span><span style="color: #D0372D;">:keys</span> <span style="color: #709870;">[</span>name location description<span style="color: #709870;">]</span><span style="color: #909183;">}</span> client<span style="color: #7388D6;">]</span>
  <span style="color: #7388D6;">(</span><span style="color: #006FE0;">println</span> name location <span style="color: #008000;">"-"</span> description<span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>
<span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">=&gt; Super Co. Philadelphia - The worldwide leader in plastic tableware.</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgd0b1ec6" class="outline-4">
<h4 id="orgd0b1ec6">Funktionsköpfe</h4>
<div class="outline-text-4" id="text-orgd0b1ec6">
<ul class="org-ul">
<li>Ein häufiger Anwendungszweck von Destructuring ist die Zerlegung von
Argumenten, die an eine Funktion übergeben werden.</li>
</ul>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8D8D84;">;;; </span><span style="color: #8D8D84; font-style: italic;">"klassisch" ohne Destructuring</span>
<span style="color: #8D8D84;">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span style="color: #707183;">(</span><span style="color: #0000FF;">defn</span> <span style="color: #006699;">print-coordinates-1</span> <span style="color: #7388D6;">[</span>point<span style="color: #7388D6;">]</span>
  <span style="color: #7388D6;">(</span><span style="color: #0000FF;">let</span> <span style="color: #909183;">[</span>x <span style="color: #709870;">(</span><span style="color: #006FE0;">first</span> point<span style="color: #709870;">)</span>
        y <span style="color: #709870;">(</span><span style="color: #006FE0;">second</span> point<span style="color: #709870;">)</span>
        z <span style="color: #709870;">(</span><span style="color: #006FE0;">last</span> point<span style="color: #709870;">)</span><span style="color: #909183;">]</span>
    <span style="color: #909183;">(</span><span style="color: #006FE0;">println</span> <span style="color: #008000;">"x:"</span> x <span style="color: #008000;">", y:"</span> y <span style="color: #008000;">", z:"</span> z<span style="color: #909183;">)</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>

<span style="color: #8D8D84;">;;; </span><span style="color: #8D8D84; font-style: italic;">mit Destructuring unter Verwendung von let</span>
<span style="color: #8D8D84;">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span style="color: #707183;">(</span><span style="color: #0000FF;">defn</span> <span style="color: #006699;">print-coordinates-2</span> <span style="color: #7388D6;">[</span>point<span style="color: #7388D6;">]</span>
  <span style="color: #7388D6;">(</span><span style="color: #0000FF;">let</span> <span style="color: #909183;">[</span><span style="color: #709870;">[</span>x y z<span style="color: #709870;">]</span> point<span style="color: #909183;">]</span>
    <span style="color: #909183;">(</span><span style="color: #006FE0;">println</span> <span style="color: #008000;">"x:"</span> x <span style="color: #008000;">", y:"</span> y <span style="color: #008000;">", z:"</span> z<span style="color: #909183;">)</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>

<span style="color: #8D8D84;">;;; </span><span style="color: #8D8D84; font-style: italic;">Anwendung von Destructuring auf die Parameterliste</span>
<span style="color: #8D8D84;">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span style="color: #707183;">(</span><span style="color: #0000FF;">defn</span> <span style="color: #006699;">print-coordinates-3</span> <span style="color: #7388D6;">[</span><span style="color: #909183;">[</span>x y z<span style="color: #909183;">]</span><span style="color: #7388D6;">]</span>
  <span style="color: #7388D6;">(</span><span style="color: #006FE0;">println</span> <span style="color: #008000;">"x:"</span> x <span style="color: #008000;">", y:"</span> y <span style="color: #008000;">", z:"</span> z<span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org9c98f20" class="outline-2">
<h2 id="org9c98f20">Curryfizierung &#x2013; partielle Anwendung von Funktionen</h2>
<div class="outline-text-2" id="text-org9c98f20">
<ul class="org-ul">
<li>ML-Funktionen akzeptieren nur ein Argument.</li>
<li>Wege, um die Übergabe mehrerer Argumente zu „simulieren“:
<ul class="org-ul">
<li>Verwendung von Tupeln (s. diverse Beispiele oben)</li>
<li><p>
Verwendung einer Funktion, die das erste Argument verarbeitet und
mit einer Funktion antwortet, die dann das nächste Argument
verarbeitet und so weiter
</p>
<blockquote>
<p>
Diese Technik wird nach dem Logiker <a href="https://de.wikipedia.org/wiki/Haskell_Brooks_Curry">Haskell Curry</a> als <i>Currying</i>
bezeichnet. Das Verb (englisch) heißt <i>currify</i>, im Deutschen mit
<i>curryfizieren</i> bezeichnet.
</p>
</blockquote></li>
</ul></li>
</ul>
</div>

<div id="outline-container-orgf27c9fc" class="outline-3">
<h3 id="orgf27c9fc">Definition und Benutzung einer curryfizierten Funktion</h3>
<div class="outline-text-3" id="text-orgf27c9fc">
<ul class="org-ul">
<li><p>
Beispiel einer Funktion mit „drei Parametern”:
</p>
<pre class="example">
val sorted3 = fn x =&gt; fn y =&gt; fn z =&gt; z &gt;= y andalso y &gt;= x
</pre></li>
<li>Der Aufruf <code>sorted3 4</code> liefert eine Funktion, in deren lokaler
Umgebung <code>x</code> definiert ist.</li>
<li>Rufen wir diese Funktion mit dem Argument 5 auf, erhalten wir eine
Funktion, in deren lokaler Umgebung <code>x</code> und <code>y</code> definiert sind.</li>
<li>Wird diese Funktion schließlich mit 6 aufgerufen, erhalten wir
<code>true</code>.</li>
<li>So kann der Ausdruck <code>((sorted3 4) 5) 6</code> nahezu wie der Aufruf einer
Funktion mit drei Argumenten angesehen werden.</li>
<li>Die Klammern sind optional: <code>sorted3 4 5 6</code>.</li>
</ul>
<ul class="org-ul">
<li><p>
Zum Vergleich die Tupel-Version
</p>
<pre class="example">
fun sorted3_tupled (x,y,z) = z &gt;= y andalso y &gt;= x
</pre>

<p>
muss so aufgerufen werden: 
</p>
<pre class="example">
sorted3_tupled(4,5,6)
</pre></li>
<li>Der Ausdruck <code>e1 e2 e3 e4</code> ist äquivalent zu <code>(((e1 e2) e3) e4)</code>.</li>
</ul>
</div>

<div id="outline-container-orgff1eccb" class="outline-4">
<h4 id="orgff1eccb">Syntaktischer Zucker für die Definition von curryfizierten Funktionen</h4>
<div class="outline-text-4" id="text-orgff1eccb">
<ul class="org-ul">
<li><p>
Die Definition von curryfizierten Funktionen mithilfe geschachtelter
Lambda-Ausdrücke wie in
</p>
<pre class="example">
val sorted3 = fn x =&gt; fn y =&gt; fn z =&gt; z &gt;= y andalso y &gt;= x
</pre>

<p>
ist etwas unhandlich und kann ersetzt werden durch:
</p>
<pre class="example">
fun sorted3 x y z = z &gt;= y andalso y &gt;= x
</pre></li>
<li><p>
Man beachte die unterschiedlichen Typen von <code>sorted3_tupled</code> und
<code>sorted3</code>: 
</p>
<pre class="example">
val sorted3_tupled = fn : int * int * int -&gt; bool
val sorted3 = fn : int -&gt; int -&gt; int -&gt; bool
</pre></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgcdb8ffc" class="outline-3">
<h3 id="orgcdb8ffc">Partielle Anwendung von curryfizierten Funktionen</h3>
<div class="outline-text-3" id="text-orgcdb8ffc">
<ul class="org-ul">
<li>In der Regel wird die Funktion <code>sorted3</code> wohl mit allen drei
Argumenten aufgerufen werden.</li>
<li>Ein Aufruf mit weniger Argumenten wird als <i>partielle Anwendung</i>
bezeichnet.</li>
<li>Ein (nicht besonders nützliches) Beispiel: <br />
<code>sorted3 0 0</code> liefert eine Funktion, die <code>true</code> liefert, wenn ihr
Argument nicht negativ ist.</li>
</ul>
</div>
<div id="outline-container-orgebd5229" class="outline-4">
<h4 id="orgebd5229">Partielle Anwendung und Funktionen höherer Ordnung</h4>
<div class="outline-text-4" id="text-orgebd5229">
<ul class="org-ul">
<li>Curryfizierung wird gerne im Zusammenhang mit den klassischen Funktionen
höherer Ordnung benutzt.</li>
<li><p>
Beipiel: Ein curryfizierte Version der Funktion <code>fold</code> für Listen
</p>
<div class="small">
<div class="org-src-container">
<pre class="src src-sml"><span style="color: #0000FF;">fun</span> <span style="color: #006699;">fold</span> f acc xs =
    <span style="color: #0000FF;">case</span> xs <span style="color: #0000FF;">of</span> <span style="color: #707183;">[]</span> =&gt; acc
             | x::xs&#8217; =&gt; fold f <span style="color: #707183;">(</span>f<span style="color: #7388D6;">(</span>acc,x<span style="color: #7388D6;">)</span><span style="color: #707183;">)</span> xs&#8217;
</pre>
</div>

</div></li>
<li><p>
Eine Funktion, die die Summe der Elemente berechnet, könnte nun
statt in der bekannten Art
</p>
<pre class="example">
fun sum1 xs = fold (fn (x,y) =&gt; x+y) 0 xs
</pre>

<p>
unter Nutzung von partieller Anwendung so definiert werden:
</p>
<pre class="example">
val sum2 = fold (fn (x,y) =&gt; x+y) 0
</pre></li>
</ul>
</div>
</div>
<div id="outline-container-org75940b5" class="outline-4">
<h4 id="org75940b5">Diverse Funktionen höherer Ordnung in ML nutzen Curryfizierung</h4>
<div class="outline-text-4" id="text-org75940b5">
<ul class="org-ul">
<li><p>
Beispiele (aus dem Modul <code>List</code>):
</p>
<pre class="example">
val List.map = fn : (’a -&gt; ’b) -&gt; ’a list -&gt; ’b list
val List.filter = fn : (’a -&gt; bool) -&gt; ’a list -&gt; ’a list
val List.foldl = fn : (’a * ’b -&gt; ’b) -&gt; ’b -&gt; ’a list -&gt; ’b
</pre></li>
<li>Der Ausdruck <code>List.foldl((fn (x,y) =&gt; x+y), 0, [3,4,5])</code> führt zu
einem Typfehler, weil <code>List.foldl</code> eine Funktion vom Typ <br />
<code>’a * ’b -&gt; ’b</code> und kein Tripel erwartet.</li>
<li>Der korrekte Aufruf muss lauten:<br />
<code>List.foldl (fn (x,y) =&gt; x+y) 0 [3,4,5]</code><br />
Er ruft <code>List.foldl</code> mit einer Funktion auf, die eine
Funktion liefert und so weiter.</li>
</ul>
<ul class="org-ul">
<li><p>
Ein anderes Beispiel einer nützlichen curryfizierten Funktion ist
<code>List.exists</code>, die wie folgt implementiert werden kann:
</p>
<div class="org-src-container">
<pre class="src src-sml"><span style="color: #0000FF;">fun</span> <span style="color: #006699;">exists</span> predicate xs =
    <span style="color: #0000FF;">case</span> xs <span style="color: #0000FF;">of</span>
        <span style="color: #707183;">[]</span> =&gt; false
      | x::xs&#8217; =&gt; predicate x <span style="color: #0000FF;">orelse</span> exists predicate xs&#8217;
</pre>
</div></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgb12c11c" class="outline-3">
<h3 id="orgb12c11c">Curryfizierung im Allgemeinen</h3>
<div class="outline-text-3" id="text-orgb12c11c">
<ul class="org-ul">
<li>Curryfizierung ist nicht nur im Zusammenhang von Funktionen höherer
Ordnung von Bedeutung.</li>
<li>Curryfizierung ist interessant für jede Funktion mit mehr als einem
Parameter und führt oft zu prägnanter Ausdrucksweise.</li>
<li><p>
Im folgenden Beispiel sind <code>zip</code> und <code>range</code> curryfiziert, <code>countup</code>
wendet <code>range</code> partiell an und <code>add_numbers</code> verwandelt die Liste
<code>[v1,v2,...,vn]</code> in <code>[(1,v1),(2,v2),...,(n,vn)]</code>.
</p>
<div class="org-src-container">
<pre class="src src-sml"><span style="color: #0000FF;">fun</span> <span style="color: #006699;">zip</span> xs ys =
    <span style="color: #0000FF;">case</span> <span style="color: #707183;">(</span>xs,ys<span style="color: #707183;">)</span> <span style="color: #0000FF;">of</span>
        <span style="color: #707183;">(</span><span style="color: #7388D6;">[]</span>,<span style="color: #7388D6;">[]</span><span style="color: #707183;">)</span> =&gt; <span style="color: #707183;">[]</span>
      | <span style="color: #707183;">(</span>x::xs&#8217;,y::ys&#8217;<span style="color: #707183;">)</span> =&gt; <span style="color: #707183;">(</span>x,y<span style="color: #707183;">)</span> :: <span style="color: #707183;">(</span>zip xs&#8217; ys&#8217;<span style="color: #707183;">)</span>
      | _ =&gt; <span style="color: #0000FF;">raise</span> Empty

<span style="color: #0000FF;">fun</span> <span style="color: #006699;">range</span> i j = <span style="color: #0000FF;">if</span> i &gt; j <span style="color: #0000FF;">then</span> <span style="color: #707183;">[]</span> <span style="color: #0000FF;">else</span> i :: range <span style="color: #707183;">(</span>i+1<span style="color: #707183;">)</span> j
<span style="color: #0000FF;">val</span> <span style="color: #BA36A5;">countup</span>  = range 1
<span style="color: #0000FF;">fun</span> <span style="color: #006699;">add_numbers</span> xs = zip <span style="color: #707183;">(</span>countup <span style="color: #7388D6;">(</span>length xs<span style="color: #7388D6;">)</span><span style="color: #707183;">)</span> xs
</pre>
</div></li>
</ul>
</div>
</div>

<div id="outline-container-org9ccce1a" class="outline-3">
<h3 id="org9ccce1a">Curryfizierung in Lisp-Sprachen</h3>
<div class="outline-text-3" id="text-org9ccce1a">
<ul class="org-ul">
<li>in Lisp-Sprachen keine syntaktische Unterstützung</li>
<li>gilt jedenfalls für Racket und Clojure</li>
<li>Curryfizierung aber durch Nutzung von Funktionen höherer Ordnung
möglich</li>
</ul>
</div>
<div id="outline-container-orgce14664" class="outline-4">
<h4 id="orgce14664">Beispiele in Clojure</h4>
<div class="outline-text-4" id="text-orgce14664">
</div>
<div id="outline-container-org60b7761" class="outline-5">
<h5 id="org60b7761">Funktion, die eine Funktion erzeugt, die eine Konstante addiert</h5>
<div class="outline-text-5" id="text-org60b7761">
<div class="small">
<div class="org-src-container">
<pre class="src src-clojure">  <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">make-add: number -&gt; (number -&gt; number)</span>
  <span style="color: #707183;">(</span><span style="color: #0000FF;">def</span> <span style="color: #BA36A5;">make-add</span>
    <span style="color: #7388D6;">(</span><span style="color: #0000FF;">fn</span> <span style="color: #909183;">[</span>a<span style="color: #909183;">]</span>
      <span style="color: #909183;">(</span><span style="color: #0000FF;">fn</span> <span style="color: #709870;">[</span>b<span style="color: #709870;">]</span>
        <span style="color: #709870;">(</span>+ a b<span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>  
</pre>
</div>

</div>
<ul class="org-ul">
<li>Anwendung</li>
</ul>
<div class="small">
<div class="org-src-container">
<pre class="src src-clojure">  <span style="color: #707183;">(</span><span style="color: #0000FF;">def</span> <span style="color: #BA36A5;">add-5</span> <span style="color: #7388D6;">(</span>make-add 5<span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>
  <span style="color: #707183;">(</span>add-5 7<span style="color: #707183;">)</span> <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">=&gt; 12</span>

  <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">oder ohne Hilfsdefintion</span>
  <span style="color: #707183;">(</span><span style="color: #7388D6;">(</span>make-add 5<span style="color: #7388D6;">)</span> 7<span style="color: #707183;">)</span> <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">=&gt; 12</span>
</pre>
</div>

</div>
<ul class="org-ul">
<li>Im Gegensatz zur Standardfunktion <code>+</code> akzeptiert die Funktion
<code>make-add</code> nicht beide Summanden als Argumente, sondern zunächst nur
einen. Das Resultat der Anwendung ist dann eine Funktion, die
wiederum einen (den zweiten) Summanden akzeptiert und auf den ersten addiert.</li>
</ul>
</div>
</div>
<div id="outline-container-org66e51f7" class="outline-5">
<h5 id="org66e51f7">Funktion, die eine Funktion erzeugt, die an eine Liste ein Element vorn anhängt</h5>
<div class="outline-text-5" id="text-org66e51f7">
<pre class="example">
;; make-prepend: X -&gt; ((list-of X) -&gt; (list-of X))

(def make-prepend
  (fn [a]
    (fn [b]
      (cons a b))))

(= ((make-prepend 5) (list 1 2 3)) (list 5 1 2 3))
(= ((make-prepend "A") (list "B" "C" "D")) (list "A" "B" "C" "D"))
</pre>
</div>
</div>
<div id="outline-container-org9d43c19" class="outline-5">
<h5 id="org9d43c19">ein ML-Beispiel</h5>
<div class="outline-text-5" id="text-org9d43c19">
<div class="org-src-container">
<pre class="src src-sml">Standard ML <span style="color: #0000FF;">of</span> New Jersey v110.84 <span style="color: #707183;">[</span>built: Tue Sep 04 08:31:43 2018<span style="color: #707183;">]</span>
- <span style="color: #0000FF;">fun</span> <span style="color: #006699;">make_mult</span> a = <span style="color: #0000FF;">fn</span> b =&gt; a * b;
<span style="color: #0000FF;">val</span> <span style="color: #BA36A5;">make_mult</span> = <span style="color: #0000FF;">fn</span> : int -&gt; int -&gt; int
- make_mult 3;
<span style="color: #0000FF;">val</span> <span style="color: #BA36A5;">it</span> = <span style="color: #0000FF;">fn</span> : int -&gt; int
- it 5;
<span style="color: #0000FF;">val</span> <span style="color: #BA36A5;">it</span> = 15 : int
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgfe78ba3" class="outline-4">
<h4 id="orgfe78ba3">Der Schönfinkel-Isomorphismus</h4>
<div class="outline-text-4" id="text-orgfe78ba3">
<ul class="org-ul">
<li>Die oben gezeigten Funktionen folgen alle dem gleichen Muster.</li>
<li>Kann dieses Muster verallgemeinert, d.&nbsp;h. in eine Funktion
abstrahiert werden?</li>
<li>Die Funktion <code>curry</code> akzeptiert eine Funktion mit zwei Argumenten
und liefert eine curryfizierte Variante zurück.</li>
<li>Die Funktion <code>uncurry</code> für die inverse Operation durch.</li>
</ul>
</div>

<div id="outline-container-org3303628" class="outline-5">
<h5 id="org3303628">Die Funktion <code>curry</code></h5>
<div class="outline-text-5" id="text-org3303628">
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">Prozedur mit zwei Parametern curryfizieren</span>
<span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">curry: (X Y -&gt; Z) -&gt; (X -&gt; (Y -&gt; Z))</span>

<span style="color: #707183;">(</span><span style="color: #0000FF;">def</span> <span style="color: #BA36A5;">curry</span>
  <span style="color: #7388D6;">(</span><span style="color: #0000FF;">fn</span> <span style="color: #909183;">[</span>proc<span style="color: #909183;">]</span>
    <span style="color: #909183;">(</span><span style="color: #0000FF;">fn</span> <span style="color: #709870;">[</span>a<span style="color: #709870;">]</span>
      <span style="color: #709870;">(</span><span style="color: #0000FF;">fn</span> <span style="color: #907373;">[</span>b<span style="color: #907373;">]</span>
        <span style="color: #907373;">(</span>proc a b<span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>

<span style="color: #707183;">(</span>= <span style="color: #7388D6;">(</span><span style="color: #909183;">(</span><span style="color: #709870;">(</span>curry +<span style="color: #709870;">)</span> 5<span style="color: #909183;">)</span> 7<span style="color: #7388D6;">)</span> 12<span style="color: #707183;">)</span>
<span style="color: #707183;">(</span>= <span style="color: #7388D6;">(</span><span style="color: #909183;">(</span><span style="color: #709870;">(</span>curry *<span style="color: #709870;">)</span> 5<span style="color: #909183;">)</span> 7<span style="color: #7388D6;">)</span> 35<span style="color: #707183;">)</span>
<span style="color: #707183;">(</span>= <span style="color: #7388D6;">(</span><span style="color: #909183;">(</span><span style="color: #709870;">(</span>curry cons<span style="color: #709870;">)</span> 5<span style="color: #909183;">)</span> <span style="color: #909183;">(</span><span style="color: #006FE0;">list</span> 1 2 3<span style="color: #909183;">)</span><span style="color: #7388D6;">)</span> <span style="color: #7388D6;">(</span><span style="color: #006FE0;">list</span> 5 1 2 3<span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>

<span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">Definition einer currifyfizierten Funktion</span>
<span style="color: #707183;">(</span><span style="color: #0000FF;">def</span> <span style="color: #BA36A5;">make-mult</span> <span style="color: #7388D6;">(</span>curry *<span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>
<span style="color: #707183;">(</span><span style="color: #7388D6;">(</span>make-mult 3<span style="color: #7388D6;">)</span> 5<span style="color: #707183;">)</span> <span style="color: #8D8D84;">;;</span><span style="color: #8D8D84; font-style: italic;">=&gt; 15</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgabb4b48" class="outline-5">
<h5 id="orgabb4b48">Die Funktion <code>uncurry</code></h5>
<div class="outline-text-5" id="text-orgabb4b48">
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">curryyfizierte Funktion entcurryfizieren</span>
<span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">uncurry (X -&gt; (Y -&gt; Z)) -&gt; (X Y -&gt; Z)</span>

<span style="color: #707183;">(</span><span style="color: #0000FF;">def</span> <span style="color: #BA36A5;">uncurry</span> 
  <span style="color: #7388D6;">(</span><span style="color: #0000FF;">fn</span> <span style="color: #909183;">[</span>proc<span style="color: #909183;">]</span>
    <span style="color: #909183;">(</span><span style="color: #0000FF;">fn</span> <span style="color: #709870;">[</span>a b<span style="color: #709870;">]</span>
      <span style="color: #709870;">(</span><span style="color: #907373;">(</span>proc a<span style="color: #907373;">)</span> b<span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>

<span style="color: #707183;">(</span>= <span style="color: #7388D6;">(</span><span style="color: #909183;">(</span>uncurry make-add<span style="color: #909183;">)</span> 5 7<span style="color: #7388D6;">)</span> 12<span style="color: #707183;">)</span>
<span style="color: #707183;">(</span>= <span style="color: #7388D6;">(</span><span style="color: #909183;">(</span>uncurry make-prepend<span style="color: #909183;">)</span> 5 <span style="color: #909183;">(</span><span style="color: #006FE0;">list</span> 1 2 3<span style="color: #909183;">)</span><span style="color: #7388D6;">)</span> <span style="color: #7388D6;">(</span><span style="color: #006FE0;">list</span> 5 1 2 3<span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org95a6456" class="outline-5">
<h5 id="org95a6456">Der Isomorphismus</h5>
<div class="outline-text-5" id="text-org95a6456">
<ul class="org-ul">
<li>Es gilt folgende Gleichung für Funktionen \(f\) mit zwei Parametern:</li>
</ul>
<p>
\[\texttt{(uncurry (curry }f\texttt{))} \equiv f\]
</p>
<ul class="org-ul">
<li><p>
Z.&nbsp;B. liefert der Ausdruck 
</p>
<pre class="example">
(= ((uncurry (curry cons)) "A" (list "B" "C" "D")) (list "A" "B" "C" "D"))
</pre>

<p>
<code>true</code>.
</p></li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Autor: Johannes Brauer</p>
<p class="date">Created: 2019-11-10 Sun 23:31</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>