<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="de" xml:lang="de">
<head>
<!-- 2019-08-05 Mon 19:14 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Relational-logische Programmierung</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Johannes Brauer" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="styles/bigblow/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="styles/bigblow/css/bigblow.css"/>
<link rel="stylesheet" type="text/css" href="styles/bigblow/css/hideshow.css"/>
<script type="text/javascript" src="styles/bigblow/js/jquery-1.11.0.min.js"></script>
<script type="text/javascript" src="styles/bigblow/js/jquery-ui-1.10.2.min.js"></script>
<script type="text/javascript" src="styles/bigblow/js/jquery.localscroll-min.js"></script>
<script type="text/javascript" src="styles/bigblow/js/jquery.scrollTo-1.4.3.1-min.js"></script>
<script type="text/javascript" src="styles/bigblow/js/jquery.zclip.min.js"></script>
<script type="text/javascript" src="styles/bigblow/js/bigblow.js"></script>
<script type="text/javascript" src="styles/bigblow/js/hideshow.js"></script>
<script type="text/javascript" src="styles/lib/js/jquery.stickytableheaders.min.js"></script>
<link rel="stylesheet" type="text/css" href="mycss/mystyle.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Relational-logische Programmierung
<br />
<span class="subtitle">Programmierparadigmen</span>
</h1>

<div id="outline-container-org0454b47" class="outline-2">
<h2 id="org0454b47">Ziele</h2>
<div class="outline-text-2" id="text-org0454b47">
<ul class="org-ul">
<li>Vermittlung von Grundkenntnissen und Fertigkeiten der
logischen/prädikativen/relationalen Programmierung</li>
<li>Kennenlernen der Syntax und Semantik von Prolog</li>
<li>Ausführung von Prolog-Programen</li>
</ul>
</div>
</div>

<div id="outline-container-orge0b679e" class="outline-2">
<h2 id="orge0b679e">Einführung</h2>
<div class="outline-text-2" id="text-orge0b679e">
<ul class="org-ul">
<li>Relational-logische Programmierung: Programme spezifizieren
Relationen zwischen Größen.</li>
<li>Logische Programmierung: Programm mit Datenstrukturen: Listen,
Binärbäume, symbolische Ausdrücke, natürliche Zahlen.</li>
<li>Der Ursprung der logischen Programmierung: automatische Theorembeweiser.</li>
<li>Sie verlangt eine Änderung der Denkweise:
<ol class="org-ol">
<li>Strukturierte logische Formeln werden als Relations- (Prozedur-)
Spezifikationen betrachtet.</li>
<li>Eine Frage zu einer logischen Implikation wird als Relations-
(Prozedur-) Aufruf betrachtet.</li>
<li>Der Beweis der Implikation ist dann die Berechnung der Antwort.</li>
</ol></li>
</ul>

<ul class="org-ul">
<li>Konkreter: Ein Axiom der Form:<br />
<code>A if B1 and B2 ... and Bn</code><br />
kann als Prozedur in einer Programmiersprache betrachtet werden:
<ul class="org-ul">
<li><code>A</code> ist der Prozedurkopf,</li>
<li>die <code>Bis</code> bilden ihren Rumpf.</li>
</ul></li>
<li>Der Versuch <code>A</code> zu lösen, wird als Ausführung der Prozedur
verstanden. Dazu muss der Ausdruck <code>B1 and B2 ... and Bn</code> gelöst
bzw. ausgeführt werden.</li>
</ul>
</div>
</div>

<div id="outline-container-org59a34fb" class="outline-2">
<h2 id="org59a34fb">Relationale Programmierung mit Prolog</h2>
<div class="outline-text-2" id="text-org59a34fb">
<ul class="org-ul">
<li>Prolog (Programming in Logic) wurde Anfang der 1970er Jahre von dem
französischen Informatiker Alain Colmerauer entwickelt.</li>
<li>Prolog hat sich als Programmiersprache über die strikte logische
Basis hinaus entwickelt: Praktische Programmierkonstrukte wie
arithmetische Operationen, Optimierungshilfmittel und Ein-/Ausgabe
sind hinzugekommen.</li>
<li>Die Darstellungen in den folgenden Abschnitten basieren auf
<a class="org-ref-reference" href="#/slide-bibliography">[Bramer2013]</a> und  <a class="org-ref-reference" href="#/slide-bibliography">[Clocksin2003]</a>.</li>
</ul>
</div>

<div id="outline-container-org01636ea" class="outline-3">
<h3 id="org01636ea">Syntax und Semantik relational-logischer Programme</h3>
<div class="outline-text-3" id="text-org01636ea">
<ul class="org-ul">
<li>Die Syntax basiert auf einer Teilmenge der Prädikatenkalküls. Ein
relational-logisches Programm besteht aus einer Menge von Formeln,
 die nach Fakten und Regeln unterschieden werden. Beide beschreiben
 bekannte Relationen auf der Problemdomäne.</li>
<li>Die Semantik besteht in einer Menge von Antworten auf Fragen.</li>
<li>Ein Programm wird ausgeführt durch eine logische Aussage, die auch
Frage oder <i>Zielausdruck</i> (oder goal oder query) genannt wird.</li>
<li>Fragen können Variablen enthalten.</li>
<li>Die Beantwortung von Fragen mit Variablen besteht darin,
Variablenbindungen zu finden, die die Frage „beweisen“.</li>
<li>Dies geschieht mithilfe zweier Techniken:
<ul class="org-ul">
<li>Unifikation: Belegung von Variablen in zwei Termen, so dass diese
gleich werden.</li>
<li>Backtracking: Suchstrategie bei der Beweisfindung.</li>
</ul></li>
<li>Es gibt nur eine primitive Operation: den Unifikationsoperator
<code>=</code>.</li>
<li>Es gibt keine Typen.</li>
</ul>
</div>
</div>
<div id="outline-container-orgb051ea3" class="outline-3">
<h3 id="orgb051ea3">Einstiegsbeispiel</h3>
<div class="outline-text-3" id="text-orgb051ea3">
<ul class="org-ul">
<li>Das „Hallo Welt“-Äquivalent für ein Prolog-Programm ist meistens
eine Wissensdatenbank mit Verwandtschaftsverhältnissen.
<ul class="org-ul">
<li>Eltern: Paul, Elfriede</li>
<li>Kinder: Klaus, Claudia, Monika</li>
</ul></li>
<li><p>
Fakten in Prolog:
</p>
<div class="org-src-container">
<pre class="src src-prolog">  vater(klaus, paul).
  vater(claudia, paul).
  vater(monika, paul).
  mutter(klaus, elfriede).
  mutter(claudia, elfriede).
  mutter(monika, elfriede).
  verheiratet(paul, elfriede).
</pre>
</div></li>
</ul>
</div>

<div id="outline-container-orga10b8fa" class="outline-4">
<h4 id="orga10b8fa">Start des Prolog-Interpreters</h4>
<div class="outline-text-4" id="text-orga10b8fa">
<ul class="org-ul">
<li>Im folgenden wird <a href="http://www.swi-prolog.org">SWI-Prolog</a> benutzt.</li>
<li>Nach dem Start des Interpreters und der Konsultation der Faktendatei
<code>stammbaum.pl</code> können Fragen an den Interpreter gestellt werden:</li>
</ul>
<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #BA36A5;">Welcome</span> to <span style="color: #BA36A5;">SWI</span>-<span style="color: #BA36A5;">Prolog</span> (threaded, 64 bits, version 7.4.2)
<span style="color: #BA36A5;">SWI</span>-<span style="color: #BA36A5;">Prolog</span> comes with <span style="color: #BA36A5;">ABSOLUTELY</span> <span style="color: #BA36A5;">NO</span> <span style="color: #BA36A5;">WARRANTY</span>. <span style="color: #BA36A5;">This</span> is free software.
<span style="color: #BA36A5;">Please</span> run ?- license. <span style="color: #006699;">for</span> legal details.

<span style="color: #BA36A5;">For</span> online help and background, visit http://www.<span style="color: #006699;">swi</span>-prolog.<span style="color: #006699;">org</span>
<span style="color: #BA36A5;">For</span> built-in help, use ?- help(<span style="color: #BA36A5;">Topic</span>). <span style="color: #006699;">or</span> ?- apropos(<span style="color: #BA36A5;">Word</span>).

1 ?- consult(<span style="color: #008000;">'stammbaum.pl'</span>).
true.

2 ?- vater(klaus, paul).
true.

3 ?- mutter(claudia, paul).
false.
</pre>
</div>
</div>
</div>
<div id="outline-container-org95b9452" class="outline-4">
<h4 id="org95b9452">Weitere Beispiele für Fragen (Zielausdrücke, goals):</h4>
<div class="outline-text-4" id="text-org95b9452">
<p>
Fragen können Variablen benutzen, die stets mit einem Großbuchstaben
beginnen müssen.
</p>
<div class="org-src-container">
<pre class="src src-prolog">?-  mutter(klaus, elfriede).
    true.
?-  vater(claudia, <span style="color: #BA36A5;">X</span>).
    <span style="color: #BA36A5;">X</span>=paul.
?-  vater(peter, <span style="color: #BA36A5;">X</span>).
    false.
?-  vater(<span style="color: #BA36A5;">X</span>, paul).
    <span style="color: #BA36A5;">X</span>=klaus<span style="color: #0000FF;">;</span>
    <span style="color: #BA36A5;">X</span>=claudia<span style="color: #0000FF;">;</span>
    <span style="color: #BA36A5;">X</span>=monika.
?-  verheiratet(<span style="color: #BA36A5;">X</span>, <span style="color: #BA36A5;">Y</span>).
    <span style="color: #BA36A5;">X</span>=paul<span style="color: #0000FF;">;</span>
    <span style="color: #BA36A5;">Y</span>=elfriede.
</pre>
</div>
</div>
</div>
<div id="outline-container-org0c4fc34" class="outline-4">
<h4 id="org0c4fc34">Regeln</h4>
<div class="outline-text-4" id="text-org0c4fc34">
<p>
Nehmen wir an, wir möchten auch Anfragen über die
Schwesterbeziehung in die Datenbasis aufnehmen, um entsprechende
Anfragen beantworten zu können. Dann hat man zwei Möglichkeiten:
</p>
<ol class="org-ol">
<li><p>
Neue Fakten hinzufügen:
</p>
<div class="small">
<div class="org-src-container">
<pre class="src src-prolog">   schwester(claudia, monika).
   schwester(monika, claudia).
   schwester(klaus, claudia).
   schwester(klaus, monika).
</pre>
</div>

</div></li>
<li>Formulierung einer Regel: <code>Y</code> ist Schwester von <code>X</code>, falls <code>Y</code> 
weiblich und Mutter von <code>X</code> gleich Mutter von <code>Y</code> ist und Vater von
<code>X</code> gleich Vater von <code>Y</code>.<br />
Dann muss man nur noch als Fakten festhalten, welche
Familienmitglieder weiblich sind. Die Regel erlaubt es, aus bekannten 
Fakten neue herzuleiten!</li>
</ol>
</div>
</div>

<div id="outline-container-org40a27ce" class="outline-4">
<h4 id="org40a27ce">Prolog-Programm mit Schwesterregel</h4>
<div class="outline-text-4" id="text-org40a27ce">
<p>
Fakten:
</p>
<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #006699;">vater</span>(klaus, paul).
<span style="color: #006699;">vater</span>(claudia, paul).
<span style="color: #006699;">vater</span>(monika, paul).
<span style="color: #006699;">mutter</span>(klaus, elfriede).
<span style="color: #006699;">mutter</span>(claudia, elfriede).
<span style="color: #006699;">mutter</span>(monika, elfriede).
<span style="color: #006699;">verheiratet</span>(paul, elfriede).
<span style="color: #006699;">weiblich</span>(claudia).
<span style="color: #006699;">weiblich</span>(monika).
<span style="color: #006699;">weiblich</span>(elfriede).
</pre>
</div>

<p>
Regeln:
</p>
<div class="small">
<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #006699;">schwester</span>(<span style="color: #BA36A5;">X</span>, <span style="color: #BA36A5;">Y</span>):- weiblich(<span style="color: #BA36A5;">Y</span>), 
       mutter(<span style="color: #BA36A5;">X</span>, <span style="color: #BA36A5;">Z</span>), mutter(<span style="color: #BA36A5;">Y</span>, <span style="color: #BA36A5;">Z</span>), 
       vater(<span style="color: #BA36A5;">X</span>, <span style="color: #BA36A5;">W</span>), vater(<span style="color: #BA36A5;">Y</span>, <span style="color: #BA36A5;">W</span>),
       <span style="color: #BA36A5;">X</span> \== <span style="color: #BA36A5;">Y</span>.
</pre>
</div>

</div>
</div>
</div>

<div id="outline-container-org6c4c25c" class="outline-4">
<h4 id="org6c4c25c">Beispielanfragen</h4>
<div class="outline-text-4" id="text-org6c4c25c">
<div class="smaller">
<div class="org-src-container">
<pre class="src src-prolog">?- schwester(klaus, claudia).
</pre>
</div>

</div>

<p>
Das Prolog-System muss
</p>

<ol class="org-ol">
<li>prüfen, ob <code>claudia</code> weiblich ist (Faktum)</li>
<li>erkennen, dass <code>mutter(klaus,Z)</code> und <code>mutter(claudia,Z)</code> gelten für
<code>Z=elfriede</code></li>
<li>erkennen, dass <code>vater(klaus,W)</code> und <code>vater(claudia,W)</code> gelten für
<code>W=Paul</code></li>
<li>daher <code>true</code> ausgeben</li>
</ol>

<div class="smaller">
<div class="org-src-container">
<pre class="src src-prolog">?- schwester(klaus, <span style="color: #BA36A5;">X</span>).
</pre>
</div>

</div>

<ul class="org-ul">
<li>Die Frage bedeutet: Wer sind die Schwestern von Klaus?</li>
<li>Das Prolog-System durchsucht seine Datenbank von Fakten (und Regeln)
in fester Reihenfolge; nämlich:
<ol class="org-ol">
<li>von oben nach unten</li>
<li>von links nach rechts</li>
</ol></li>
<li><p>
Daher liefert die Anfrage die Antwort:
</p>

<div class="small">
<div class="org-src-container">
<pre class="src src-prolog">   <span style="color: #BA36A5;">X</span>=claudia<span style="color: #0000FF;">;</span>
   <span style="color: #BA36A5;">X</span>=monika<span style="color: #0000FF;">;</span>
   false.
</pre>
</div>

</div></li>
</ul>

<div class="smaller">
<div class="org-src-container">
<pre class="src src-prolog">?- schwester(<span style="color: #BA36A5;">X</span>, <span style="color: #BA36A5;">Y</span>).
</pre>
</div>

</div>

<p>
Es ist nicht schwer zu sehen, dass aufgrund der o.g. Auswertestrategie
folgende Ausgabe erzeugt wird:
</p>

<div class="small">
<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #BA36A5;">X</span> = klaus, <span style="color: #BA36A5;">Y</span> = claudia <span style="color: #0000FF;">;</span>
<span style="color: #BA36A5;">X</span> = monika, <span style="color: #BA36A5;">Y</span> = claudia <span style="color: #0000FF;">;</span>
<span style="color: #BA36A5;">X</span> = klaus, <span style="color: #BA36A5;">Y</span> = monika <span style="color: #0000FF;">;</span>
<span style="color: #BA36A5;">X</span> = claudia, <span style="color: #BA36A5;">Y</span> = monika <span style="color: #0000FF;">;</span>
false.
</pre>
</div>

</div>
</div>
</div>
<div id="outline-container-org334b1da" class="outline-4">
<h4 id="org334b1da">modus ponens</h4>
<div class="outline-text-4" id="text-org334b1da">
<ul class="org-ul">
<li>Die oben gezeigten Ableitungen basieren auf dem <i>modus ponens</i>,
einer Schlussregel der Logik:<br />
Aus den Prämissen <i>Wenn A dann B</i> und <i>A</i> lässt sich <i>B</i>
schlussfolgern.</li>
<li>Mit anderen Worten: Der logische Ausdruck
\[((A\to B)\wedge A)\to B\]
ist eine Tautologie.</li>
<li>Die oben genannte Beispielanfrage <code>schwester(klaus, claudia).</code>
entspricht dem <i>B</i>.</li>
<li><p>
Die rechte Seite der Schwesterregel
</p>
<pre class="example">
weiblich(Y), mutter(X, Z), mutter(Y, Z), vater(X, W), vater(Y, W), X \== Y.
</pre>

<p>
entpricht dem <i>A</i>. Wenn also <i>A</i> bewiesen werden kann,
d.&nbsp;h. eine Belegung der Variablen <code>X, Y, W</code> und <code>Z</code> gefunden
werden kann, für die alle Teilausdrücke von <i>A</i> wahr werden, ist
auch <i>B</i> bewiesen. 
</p></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgc3df8f2" class="outline-3">
<h3 id="orgc3df8f2">Basiskonzepte von Prolog</h3>
<div class="outline-text-3" id="text-orgc3df8f2">
</div>
<div id="outline-container-org413142d" class="outline-4">
<h4 id="org413142d">Terme</h4>
<div class="outline-text-4" id="text-org413142d">
<ul class="org-ul">
<li>Alle Daten (einschließlich der Prolog-Programme) in Prolog werden
durch <i>Terme</i> repräsentiert.</li>
<li>Ein Term ist:
<dl class="org-dl">
<dt>ein <i>Atom</i></dt><dd>Beispiele sind <code>elmshorn</code>, <code>claudia</code>. Atome beginnen
mit einem Kleinbuchstaben.</dd>
<dt>eine <i>Variable</i></dt><dd>Variablen beginnen mit einem Großbuchstaben oder
dem Unterstrich. Ein singulärer Unterstrich bezeichnet die
<i>anonyme Variable</i>, die für „irgendeinen Term” steht.</dd>
<dt>eine <i>Ganzzahl</i> oder eine <i>Gleitkommazahl</i></dt><dd></dd>

<dt>ein <i>zusammengesetzter Term</i> (compound term)</dt><dd>Wenn \(t_1, t_2, \ldots ,t_n\) Terme sind, dann ist auch \(f(t_1,
      t_2, \ldots ,t_n)\) ein Term. &nbsp; \(f\) heißt Funktor und \(n\) ist die
  Stelligkeit (arity) des zusammen&#x00ad;gesetzten Terms.<br />
  Beispiele: <code>f(a)</code>, <code>g(f(X))</code>, <code>+(a, f(X))</code></dd>
</dl></li>
</ul>
</div>
<div id="outline-container-orgfb0b8d2" class="outline-5">
<h5 id="orgfb0b8d2">Übersicht</h5>
<div class="outline-text-5" id="text-orgfb0b8d2">

<div class="figure">
<p><img src="./Abbildungen/prologterme.png" alt="prologterme.png" width="750px" />
</p>
</div>
</div>
</div>
<div id="outline-container-org8a70753" class="outline-5">
<h5 id="org8a70753">Stelligkeit</h5>
<div class="outline-text-5" id="text-org8a70753">
<ul class="org-ul">
<li>In Prolog können zwei Prädikate mit demselben Funktor aber
unterschiedlicher Stelligkeit definiert werden.</li>
<li>Prolog behandelte diese als zwei verschiedene Prädikate.</li>
<li>In der Prolog-Dokumentation wird die Stelligkeit eines Prädikats
durch Anhängen von "/" gefolgt von der Zahl, die die Stelligkeit
angibt, dargestellt.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgcffc7da" class="outline-4">
<h4 id="orgcffc7da">Programme</h4>
<div class="outline-text-4" id="text-orgcffc7da">
<ul class="org-ul">
<li>Ein Prolog-Programm besteht aus einer Menge von Prädikaten.</li>
<li>Prädikate beschreiben Relationen zwischen ihren Argumenten. Logisch
betrachtet beschreibt ein Prolog-Programm, was gilt.</li>
<li>Jedes <i>Prädikat</i> besitzt ein Atom als Namen und beliebig viele Argumente.</li>
<li>Jedes Argument ist ein Prolog-Term.</li>
<li>Ein Prädikat mit dem Namen <code>Pred</code> und \(n\) Argumenten wird durch
einen Prädikatsindikator notiert: <code>Pred/n</code>. \(n\) ist die Stelligkeit
des Prädikats.</li>
<li>Ein Prädikat wird durch eine Menge von <i>Klauseln</i> (s. u.) definiert.</li>
<li>Die Klauseln, die ein Prädikat definieren, stellen logische
Alternativen dar. Wenn eine der Klauseln wahr ist, ist das ganze
Prädikat war.</li>
</ul>
</div>
</div>
<div id="outline-container-org1001709" class="outline-4">
<h4 id="org1001709">Klauseln &#x2013; Regeln</h4>
<div class="outline-text-4" id="text-org1001709">
<ul class="org-ul">
<li>Ein Klausel ist entweder ein <i>Fakt</i> oder eine <i>Regel</i>.</li>
<li>Eine Regel hat die Form:<br />
<code>Kopf :- Rumpf.</code>
<ul class="org-ul">
<li>Die Form des <code>Kopf</code> hängt von der Zahl der Argumente des Prädikats
ab:
<ul class="org-ul">
<li>Besitzt das Prädikat keine Argumente, dann besteht der <code>Kopf</code>
nur aus dem Namen des Prädikats, ist also ein Atom.</li>
<li>Andernfalls ist <code>Kopf</code> ein zusammengesetzter Term, z. B.:<br />
<code>schwester(X, Y)</code></li>
</ul></li>
<li>Der <code>Rumpf</code> hat die Form: \(B_1,\ldots,B_n\), wobei die \(B_i\) Terme
sind, die mit dem Komma konjunktiv verknüpft sind.</li>
<li>Die Zeichenfolge <code>:-</code> steht für die logische Implikation,
gerichtet vom Rumpf zum Kopf.</li>
</ul></li>
</ul>
<ul class="org-ul">
<li><p>
Z. B. kann die Regel<br />
</p>
<pre class="example">
father(Dad, Child) :- parent(Dad, Child), male(Dad).
</pre>

<p>
wie folgt gelesen werden: <code>Dad</code> (eine Variable) ist <code>father</code> von
<code>Child</code> (Variable), wenn <code>Dad</code> <code>parent</code> von <code>Child</code> und <code>Dad</code>
<code>male</code> ist.
</p></li>
</ul>
</div>
</div>
<div id="outline-container-orge97f740" class="outline-4">
<h4 id="orge97f740">Klauseln &#x2013; Fakten</h4>
<div class="outline-text-4" id="text-orge97f740">
<ul class="org-ul">
<li>Ein Faktum wird so aufgeschrieben:<br />
<code>Kopf.</code></li>
<li>Dieser Ausdruck ist äquivalent zur Regel:<br />
<code>Kopf :- true.</code></li>
<li>Logisch bedeutet das, dass die Regel immer wahr ist, weil das
Standardprädikat <code>true/0</code> immer wahr ist.</li>
</ul>
</div>
</div>
<div id="outline-container-orgcedbb1a" class="outline-4">
<h4 id="orgcedbb1a">Starten von Prolog-Programmen</h4>
<div class="outline-text-4" id="text-orgcedbb1a">
<ul class="org-ul">
<li>Eingabe von Fragen/Zielausdrücken (queries) am Eingabeprompt des
Prolog-Interpreters</li>
<li>Ein Zielausdruck besteht aus dem Namen eines beliebigen Prädikats
und seiner Argumente.</li>
<li>Eine Frage kann aus der Und-Verknüpfung von mehreren Zielausdrücken
bestehen.</li>
<li>In einer Frage sind Variabeln existenz-quantifiziert. Eine Frage
<code>p(X)</code> kann so gelesen werden: Existiert eine Variablenbindung für
X, so dass <code>p(X)</code> wahr wird.</li>
<li>Wenn eine passende Variablenbindung gefunden werden kann (the goal
succeeds), antwortet der Interpreter mit einem logisch äquivalenten
Zielausdruck.</li>
<li>Wenn eine Frage mehrere Antworten hat, liefert der Interpreter die
übrigen auf besondere Anforderung (in SWI-Prolog durch Eingabe von
Leerzeichen oder Semikolon).</li>
</ul>
</div>
</div>

<div id="outline-container-org1318d8a" class="outline-4">
<h4 id="org1318d8a">Ausführung von Prolog-Programmen</h4>
<div class="outline-text-4" id="text-org1318d8a">
<p>
Die operationale Semantik von Prolog
</p>
<ul class="org-ul">
<li>Die Ausführung von Prolog-Code kann als ein Spezialfall einer
<i>Resolution</i> betrachtet werden.</li>
<li>Die Resolution ist ein Verfahren der formalen Logik, um die
Gültigkeit einer logischen Formel zu prüfen. Dabei wird versucht,
aus der Verneinung der Frage einen Widerspruch abzuleiten.</li>
<li>Wenn ein Widerspruch gefunden wird, ist die Frage die logische
Folgerung aus dem Programm.</li>
<li>Ein wichtiger Schritt in diesem Prozess ist die Unifikation von
Termen.</li>
<li>Wird der Kopf einer Klausel für die Unifikation mit einem
Zielausdruck ausgewählt, wird diese auf die Argumente von beiden
Termen angewendet.</li>
<li>Daraus folgt, dass es in Prolog keine Unterscheidung zwischen Ein-
und Ausgabeparametern gibt.
(Vgl. <a href="PP2-7-RelProgUebrscht.html#beispiel-natuerliche-zahlen">Implementierung von natürlichen Zahlen</a>!)</li>
</ul>
<ul class="org-ul">
<li>Sind die Köpfe mehrerer Klauseln mit einem Zielausdruck
unifizierbar, werden die Alternativen durch <i>Backtracking</i>
abgearbeitet.</li>
<li>Informell kann die Ausführungsstrategie von Prolog als Tiefensuche
(depth-first search) mit <i>chronologischem Backtracking</i> betrachtet
werden (nähere Erläuterung s.&nbsp;u.).</li>
</ul>
</div>
</div>
<div id="outline-container-orged91dd1" class="outline-4">
<h4 id="orged91dd1">Unifikation</h4>
<div class="outline-text-4" id="text-orged91dd1">
</div>
<div id="outline-container-orgeace8da" class="outline-5">
<h5 id="orgeace8da">Informelle Definition:</h5>
<div class="outline-text-5" id="text-orgeace8da">
<blockquote>
<p>
Zwei Terme sind unifizierbar, wenn sie identisch sind oder Variablen
enthalten, die einheitlich mit Termen so belegt werden können, dass
sie gleich (unifiziert) sind.
</p>
</blockquote>
<ul class="org-ul">
<li>Beispiele:
<ul class="org-ul">
<li>karin und karin sind unifiziert.</li>
<li>42 und 42 sind unifiziert.</li>
<li>weiblich(karla) und weiblich(karla) sind unifiziert.</li>
<li>klara und rosa sind nicht unifizierbar.</li>
<li>weiblich(karla) und weiblich(rosa) sind nicht unifizierbar.</li>
</ul></li>
</ul>
<ul class="org-ul">
<li>Welche der folgenden Term-Paare sind unifizierbar?
<ul class="org-ul">
<li>rosa und X</li>
<li>weiblich(X) und weiblich(klara)</li>
<li>liebt(rosa,X) und liebt(X,karl)</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgf38bdb2" class="outline-5">
<h5 id="orgf38bdb2">Präzise Definition</h5>
<div class="outline-text-5" id="text-orgf38bdb2">
<ol class="org-ol">
<li>Sind \(t_1\) und \(t_2\) Konstanten, dann sind \(t_1\) und \(t_2\)
unifizierbar, wenn sie dasselbe Atom oder dieselbe Zahl sind.</li>
<li>Ist \(t_1\) eine Variable und \(t_2\) irgendein Term, dann sind \(t_1\)
und \(t_2\) unifizierbar, wenn \(t_1\) mit  \(t_2\) belegt wird (und umgekehrt).</li>
<li>Sind \(t_1\) und \(t_2\) komplexe Terme, dann sind sie unifizierbar, wenn:
<ol class="org-ol">
<li>sie denselben Funktor mit derselben Stelligkeit besitzen, <b>und</b></li>
<li>alle ihre korrespondierenden Argumente unifizierbar sind, <b>und</b></li>
<li>die Variablenbelegungen kompatibel sind.</li>
</ol></li>
</ol>
</div>
</div>
<div id="outline-container-orgdded48b" class="outline-5">
<h5 id="orgdded48b">Anwendungsbeispiele für <code>=/2</code></h5>
<div class="outline-text-5" id="text-orgdded48b">
<div class="org-src-container">
<pre class="src src-prolog">?- claudia = claudia.
... .

?- claudia = claudius.
... .

?- claudia = <span style="color: #BA36A5;">X</span>.
... .

?- <span style="color: #BA36A5;">X</span> = claudia, <span style="color: #BA36A5;">X</span> = claudius.
... .

?- k(s(g),<span style="color: #BA36A5;">Y</span>) = k(<span style="color: #BA36A5;">X</span>,t(k)).
... ,
...  .

?- father(<span style="color: #BA36A5;">X</span>) = <span style="color: #BA36A5;">X</span>.
... .
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgf5d287c" class="outline-4">
<h4 id="orgf5d287c">Standardprädikate</h4>
<div class="outline-text-4" id="text-orgf5d287c">
<ul class="org-ul">
<li>Es gibt einige vordefinierte Standardprädikate, z. B.
<ul class="org-ul">
<li><code>=/2</code> ist wahr, wenn seine Argumente unifizierbar sind;</li>
<li><code>true/0</code> ist immer wahr, <code>false/0</code> immer falsch;</li>
<li><code>dif/2</code> is wahr genau dann, wenn die Argumente unterschiedliche
Terme sind;</li>
<li><code>,/2</code> bezeichnet die Konjunktion, <code>;/2</code> die Disjunktion.</li>
</ul></li>
<li>Standardprädikate für den Vergleich von Zahlen (alle zweistellig):
<ul class="org-ul">
<li><code>=:=</code>, <code>=\=</code> numerische Gleichheit, Ungleichheit</li>
<li><code>&lt;</code>, <code>&gt;</code>, <code>=&lt;</code>, <code>&gt;=</code></li>
</ul></li>
<li>Arithmetische Operationen (alle zweistellig):<br />
<code>+ - * / // mod</code><br />
Es gelten die üblichen Vorrangregeln.</li>
<li>Die Standardprädikate für Zahlen können in Infixnotation geschrieben
werden, also <code>3 + 4</code> anstatt <code>+(3, 4)</code>.</li>
</ul>
<ul class="org-ul">
<li><p>
Beachte: Der Unifikationsoperator <code>=/2</code> bewirkt keine Auswertung
arithmetischer Ausdrücke, dafür steht der Operator <code>is/2</code> zur
Verfügung:
</p>
<div class="smaller">
<div class="org-src-container">
<pre class="src src-prolog">  ?- <span style="color: #BA36A5;">X</span> = 3 + 4.
  <span style="color: #BA36A5;">X</span> = 3+4.
  ?- <span style="color: #BA36A5;">X</span> is 3+4.
  <span style="color: #BA36A5;">X</span> = 7.
</pre>
</div>

</div></li>
</ul>
</div>
</div>

<div id="outline-container-orgecbee68" class="outline-4">
<h4 id="orgecbee68">Resolution / Backtracking</h4>
<div class="outline-text-4" id="text-orgecbee68">
<ul class="org-ul">
<li>Resolution: Grundlage für eine automatische Beweisführung</li>
<li>basiert auf dem Prinzip der Unifikation und des automatischen
Rücksetzens (Backtracking).</li>
<li>Prolog benutzt Tiefensuche; Reihenfolge der Klauseln entscheidend</li>
<li>Teilziele einer Anfrage werden von links nach rechts bearbeitet.</li>
<li>Zu jedem Teilziel wird die im Programmtext erste Klausel ausgewählt
und versucht mit dem Teilziel zu unifizieren.</li>
<li>Ist die Klausel eine Regel, so wird das Teilziel durch den
Regelrumpf ersetzt und versucht zu beweisen. Andernfalls wird
versucht das nächste Ziel der Anfrage herzuleiten.</li>
<li>Tritt während der Resolution ein Fehler bei der Unifikation auf,
wird also keine passende Programmklausel gefunden, so springt das
PROLOG-System durch das eingebaute Rücksetzen auf den letzten Punkt
zurück, an dem eine Entscheidung getroffen wurde, hebt die an dieser
Stelle gemachten Variablenbindungen auf und wählt die nächste
alternative Klausel aus.</li>
</ul>
</div>
<div id="outline-container-orge2a6faf" class="outline-5">
<h5 id="orge2a6faf">Beispiel</h5>
<div class="outline-text-5" id="text-orge2a6faf">
<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #006699;">father</span>(abraham,isaac).
<span style="color: #006699;">father</span>(haran,lot).
<span style="color: #006699;">father</span>(haran,milcah).
<span style="color: #006699;">father</span>(haran,yiscah).
<span style="color: #006699;">male</span>(isaac).
<span style="color: #006699;">male</span>(lot).
<span style="color: #006699;">female</span>(milcah).
<span style="color: #006699;">female</span>(yiscah).
<span style="color: #006699;">son</span>(<span style="color: #BA36A5;">X</span>,<span style="color: #BA36A5;">Y</span>) :- father(<span style="color: #BA36A5;">Y</span>,<span style="color: #BA36A5;">X</span>), male(<span style="color: #BA36A5;">X</span>).
<span style="color: #006699;">daughter</span>(<span style="color: #BA36A5;">X</span>,<span style="color: #BA36A5;">Y</span>) :- father(<span style="color: #BA36A5;">Y</span>,<span style="color: #BA36A5;">X</span>), female(<span style="color: #BA36A5;">X</span>).
</pre>
</div>
<p>
Nachfolgend wird die Resolution der Anfrage
</p>
<pre class="example">
daughter(X,haran).
</pre>

<p>
gezeigt.
</p>
<div class="nebeneinander">
<ol class="org-ol">
<li>Prolog sucht passende Programmklausel<br />
Unifikation <code>daughter(X,Y)</code> und <code>daughter(X,haran)</code> <br />
\(\rightarrow\) Substitution <code>Y=haran</code></li>
</ol>

</div>
<div class="nebeneinander">

<div class="figure">
<p><img src="./Abbildungen/bibel.png" alt="bibel.png" width="350px" />
</p>
</div>

</div>
<div class="clear">

</div>
<ol class="org-ol">
<li value="2">Das ursprüngliche Ziel wird durch den Regelrumpf ersetzt<br />
\(\rightarrow\) neue Zielanfrage: <code>father(haran,X), female(X).</code></li>
<li>linkes Teilziel wird ausgewählt: <code>father(haran,X)</code><br />
erste Programmklausel wird ausgewählt: <code>father(abraham,isaac).</code><br />
\(\rightarrow\) Unifikation nicht möglich<br />
\(\rightarrow\) Backtracking</li>
<li>nächste alternative Programmklausel wird ausgewählt: <code>father(haran,lot)</code><br />
\(\rightarrow\) Substitution <code>X=lot</code></li>
</ol>
<div class="nebeneinander">
<ol class="org-ol">
<li value="5">rechtes Teilziel wird ausgewählt und Substitution angewendet: <code>female(lot)</code><br />
\(\rightarrow\) keine passende Programmklausel vorhanden \(\rightarrow\) Backtracking</li>
</ol>

</div>
<div class="nebeneinander">

<div class="figure">
<p><img src="./Abbildungen/bibel.png" alt="bibel.png" width="350px" />
</p>
</div>

</div>
<div class="clear">

</div>
<ol class="org-ol">
<li value="6">Substitution <code>X=lot</code> wird aufgehoben, nächste Klausel im
Programmtext ausgewählt: <code>father(haran,milcah)</code> <br />
\(\rightarrow\) Substitution <code>X=milcah</code></li>
<li>rechtes Teilziel wird ausgewählt und Substitution angewendet:
<code>female(milcah)</code><br />
\(\rightarrow\) passende Programmklausel vorhanden
\(\rightarrow\) Prolog gibt die Substitution <code>X=milcah</code> aus</li>
<li>Durch Eingabe von <code>;</code> wird manuell Backtracking erzwungen um
alternative Lösungen zu finden</li>
</ol>
<div class="nebeneinander">
<ol class="org-ol">
<li value="9">Substitution <code>X=milcah</code> wird aufgehoben, nächste Klausel im
Programmtext ausgewählt: <code>father(haran,yiscah)</code> <br />
\(\rightarrow\) Substitution <code>X=yiscah</code></li>
</ol>

</div>
<div class="nebeneinander">

<div class="figure">
<p><img src="./Abbildungen/bibel.png" alt="bibel.png" width="350px" />
</p>
</div>

</div>
<div class="clear">

</div>
<ol class="org-ol">
<li value="10">rechtes Teilziel wird ausgewählt und Substitution angewendet:<br />
<code>female(yiscah)</code> <br />
\(\rightarrow\) passende Programmklausel vorhanden<br />
\(\rightarrow\) Prolog gibt die Substitution <code>X=yiscah.</code> aus und
schließt die Beantwortung der ursprünglichen Anfrage, da
keine Alternativen mehr vorhanden sind.</li>
</ol>
</div>
</div>
</div>
</div>
<div id="outline-container-orgbc82053" class="outline-3">
<h3 id="orgbc82053">Rekursion</h3>
<div class="outline-text-3" id="text-orgbc82053">
<ul class="org-ul">
<li>Davon, dass Prolog rekursive Regeln erlaubt, wurde schon in bei der
logischen <a href="PP2-7-RelProgUebrscht.html#beispiel-natuerliche-zahlen">Implementierung von natürlichen Zahlen</a> Gebrauch gemacht.</li>
<li>Weiteres Beispiel, das die Notwendigkeit, Regeln rekursiv
definieren zu können, deutlich macht.</li>
<li><p>
Modifikation des Stammbaum-Beispiels, zunächst ein paar Fakten:
</p>
<div class="smaller">
<div class="org-src-container">
<pre class="src src-prolog">  mutter(klaus, elfriede).
  mutter(claudia, elfriede).
  mutter(elfriede, rosa).
  mutter(rosa, klara)
</pre>
</div>

</div></li>
<li><p>
Gesucht ein Prädikat, das erlaubt festzustellen, ob eine Person
Abkömmling einer anderen Person ist. Z.&nbsp;B. sollte die folgende
Frage mit <code>true</code> beantwortet werden:
</p>
<pre class="example">
abkoemmling(klara, elfriede). 
</pre></li>
</ul>
<ul class="org-ul">
<li><p>
Wie lautet das Prädikat <code>abkoemling(X,Y)</code>?<br />
</p>
<div class="small">
<div class="org-src-container">
<pre class="src src-prolog">  mutter(klaus, elfriede).
  mutter(claudia, elfriede).
  mutter(elfriede, rosa).
  mutter(rosa, klara)
 
  abkoemling(<span style="color: #BA36A5;">X</span>,<span style="color: #BA36A5;">Y</span>) :- <span style="color: #8D8D84; font-style: italic;">% Y ist Abk&#246;mmling von X</span>
</pre>
</div>

</div>
<div class="small">
<div class="org-src-container">
<pre class="src src-prolog">  abkoemmling(<span style="color: #BA36A5;">X</span>,<span style="color: #BA36A5;">Y</span>) :- mutter(<span style="color: #BA36A5;">Y</span>,<span style="color: #BA36A5;">X</span>).
  abkoemmling(<span style="color: #BA36A5;">X</span>,<span style="color: #BA36A5;">Y</span>) :- mutter(<span style="color: #BA36A5;">Z</span>,<span style="color: #BA36A5;">X</span>), abkoemmling(<span style="color: #BA36A5;">Z</span>,<span style="color: #BA36A5;">Y</span>).
</pre>
</div>

</div>
<ul class="org-ul">
<li>Warum ist Rekursion hier erforderlich?</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgd0541b9" class="outline-3">
<h3 id="orgd0541b9">Listen in Prolog</h3>
<div class="outline-text-3" id="text-orgd0541b9">
<ul class="org-ul">
<li>Listen in Prolog ähneln bis auf die Syntax den aus Racket oder
Clojure bekannten.
<ul class="org-ul">
<li>Beispiel: <code>[3,4,5,6,7]</code></li>
</ul></li>
<li>Sie können heterogen sein.
<ul class="org-ul">
<li>Beispiel: <code>(a, 3, 2.0, f(a), g[X])</code></li>
</ul></li>
<li>Die leere Liste: <code>[]</code></li>
<li>Jede Liste außer der leeren besteht aus zwei Teilen: dem ersten Element (head) und
der Restliste (tail).</li>
<li>Der senkrechte Strich entspricht der aus den Lisp-Sprachen bekannten
<code>cons</code>-Funktion. 
<ul class="org-ul">
<li><p>
Beispiele:
</p>
<div class="small">
<div class="org-src-container">
<pre class="src src-prolog">    ?- <span style="color: #0000FF;">[</span>a, b, c, d<span style="color: #0000FF;">]</span> = <span style="color: #0000FF;">[</span>a <span style="color: #0000FF;">|</span> <span style="color: #0000FF;">[</span>b, c, d<span style="color: #0000FF;">]]</span>.
    true.
    ?- <span style="color: #0000FF;">[</span><span style="color: #BA36A5;">H</span> <span style="color: #0000FF;">|</span> <span style="color: #BA36A5;">T</span><span style="color: #0000FF;">]</span> = <span style="color: #0000FF;">[</span>a, b, c, d<span style="color: #0000FF;">]</span>.
    <span style="color: #BA36A5;">H</span> = a,
    <span style="color: #BA36A5;">T</span> = <span style="color: #0000FF;">[</span>b, c, d<span style="color: #0000FF;">]</span>.    
</pre>
</div>

</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org1a75fd1" class="outline-3">
<h3 id="org1a75fd1">Beipiele für Listen-Prädikate</h3>
<div class="outline-text-3" id="text-org1a75fd1">
</div>
<div id="outline-container-orgb7d7d0d" class="outline-4">
<h4 id="orgb7d7d0d"><code>member</code></h4>
<div class="outline-text-4" id="text-orgb7d7d0d">
<ul class="org-ul">
<li><p>
Die Frage <code>member(X, L)</code> soll genau dann <code>true</code> liefern, wenn <code>X</code> in
der Liste <code>L</code> vorkommt.
</p>
<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #006699;">member</span>(<span style="color: #BA36A5;">X</span>,<span style="color: #0000FF;">[</span><span style="color: #BA36A5;">X</span><span style="color: #0000FF;">|</span><span style="color: #BA36A5;">T</span><span style="color: #0000FF;">]</span>).                <span style="color: #8D8D84; font-style: italic;">% besser: member(X,[X|_]).</span>
<span style="color: #006699;">member</span>(<span style="color: #BA36A5;">X</span>,<span style="color: #0000FF;">[</span><span style="color: #BA36A5;">H</span><span style="color: #0000FF;">|</span><span style="color: #BA36A5;">T</span><span style="color: #0000FF;">]</span>) :- member(<span style="color: #BA36A5;">X</span>,<span style="color: #BA36A5;">T</span>). <span style="color: #8D8D84; font-style: italic;">% besser: member(X,[_|T]) :- member(X,T).</span>

?- member(a, <span style="color: #0000FF;">[</span>b, a, c<span style="color: #0000FF;">]</span>).
true 

?- member(a, <span style="color: #0000FF;">[</span>b, c, d<span style="color: #0000FF;">]</span>).
false

?- member(a, <span style="color: #0000FF;">[]</span>).
false.

?- member(<span style="color: #BA36A5;">X</span>, <span style="color: #0000FF;">[</span>a, b, c<span style="color: #0000FF;">]</span>).
<span style="color: #BA36A5;">X</span> = a <span style="color: #0000FF;">;</span>
<span style="color: #BA36A5;">X</span> = b <span style="color: #0000FF;">;</span>
<span style="color: #BA36A5;">X</span> = c <span style="color: #0000FF;">;</span>
false.
</pre>
</div></li>
</ul>
</div>
</div>

<div id="outline-container-org942f7aa" class="outline-4">
<h4 id="org942f7aa"><code>count</code></h4>
<div class="outline-text-4" id="text-org942f7aa">
<ul class="org-ul">
<li><p>
<code>count</code> soll die Anzahl der Elemente einer Liste ermitteln.
</p>
<ol class="org-ol">
<li>Die Anzahl der Elemente der leeren Liste ist \(0\).</li>
<li>Die Anzahl der Elemente der nicht-leeren Liste ist \(1 +
     count(T)\), wobei \(T\) die Restliste ist.</li>
</ol>
<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #006699;">count</span>(<span style="color: #0000FF;">[]</span>,0).
<span style="color: #006699;">count</span>(<span style="color: #0000FF;">[</span><span style="color: #BA36A5;">_</span><span style="color: #0000FF;">|</span><span style="color: #BA36A5;">T</span><span style="color: #0000FF;">]</span>,<span style="color: #BA36A5;">N</span>) :- count(<span style="color: #BA36A5;">T</span>, <span style="color: #BA36A5;">X</span>), <span style="color: #BA36A5;">N</span> is <span style="color: #BA36A5;">X</span>+1.

?- count(<span style="color: #0000FF;">[]</span>, <span style="color: #BA36A5;">N</span>).
<span style="color: #BA36A5;">N</span> = 0.

?- count(<span style="color: #0000FF;">[</span>a, b, c<span style="color: #0000FF;">]</span>, <span style="color: #BA36A5;">N</span>).
<span style="color: #BA36A5;">N</span> = 3.

?- count(<span style="color: #0000FF;">[</span>a, b, c<span style="color: #0000FF;">]</span>, 3).
true.

?- count(<span style="color: #0000FF;">[</span>a, <span style="color: #0000FF;">[</span>1, 2<span style="color: #0000FF;">]</span>, c<span style="color: #0000FF;">]</span>, 3).
true.

?- count(<span style="color: #BA36A5;">X</span>, 3).
<span style="color: #BA36A5;">X</span> = <span style="color: #0000FF;">[</span><span style="color: #BA36A5;">_6622</span>, <span style="color: #BA36A5;">_6628</span>, <span style="color: #BA36A5;">_6634</span><span style="color: #0000FF;">]</span> 
</pre>
</div></li>
</ul>
</div>
<div id="outline-container-org29f3edf" class="outline-5">
<h5 id="org29f3edf">Endrekursive Variante mit akkumulierendem Parameter</h5>
<div class="outline-text-5" id="text-org29f3edf">
<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #006699;">acCount</span>(<span style="color: #0000FF;">[</span><span style="color: #BA36A5;">_</span><span style="color: #0000FF;">|</span><span style="color: #BA36A5;">T</span><span style="color: #0000FF;">]</span>,<span style="color: #BA36A5;">A</span>,<span style="color: #BA36A5;">L</span>) :- <span style="color: #BA36A5;">An</span> is <span style="color: #BA36A5;">A</span>+1, acCount(<span style="color: #BA36A5;">T</span>,<span style="color: #BA36A5;">An</span>,<span style="color: #BA36A5;">L</span>). 
<span style="color: #006699;">acCount</span>(<span style="color: #0000FF;">[]</span>,<span style="color: #BA36A5;">A</span>,<span style="color: #BA36A5;">A</span>).

<span style="color: #006699;">countAcc</span>(<span style="color: #BA36A5;">L</span>,<span style="color: #BA36A5;">N</span>) :- acCount(<span style="color: #BA36A5;">L</span>,0,<span style="color: #BA36A5;">N</span>).

?- countAcc(<span style="color: #0000FF;">[</span>a, <span style="color: #0000FF;">[</span>1, 2<span style="color: #0000FF;">]</span>, c<span style="color: #0000FF;">]</span>, 3).
true.

<span style="color: #8D8D84;">%% </span><span style="color: #8D8D84; font-style: italic;">Benutzung der Trace-Funktion von SWI-Prolog</span>
?- trace.
true.

<span style="color: #0000FF;">[</span>trace<span style="color: #0000FF;">]</span> 10 ?- acCount(<span style="color: #0000FF;">[</span>a, b, c<span style="color: #0000FF;">]</span>,0,<span style="color: #BA36A5;">N</span>).
   <span style="color: #BA36A5;">Call</span>: (8) acCount(<span style="color: #0000FF;">[</span>a, b, c<span style="color: #0000FF;">]</span>, 0, <span style="color: #BA36A5;">_1850</span>) ? 
   <span style="color: #BA36A5;">Call</span>: (9) <span style="color: #BA36A5;">_2100</span> is 0+1 ? 
   <span style="color: #BA36A5;">Exit</span>: (9) 1 is 0+1 ? 
   <span style="color: #BA36A5;">Call</span>: (9) acCount(<span style="color: #0000FF;">[</span>b, c<span style="color: #0000FF;">]</span>, 1, <span style="color: #BA36A5;">_1850</span>) ? 
   <span style="color: #BA36A5;">Call</span>: (10) <span style="color: #BA36A5;">_2106</span> is 1+1 ? 
   <span style="color: #BA36A5;">Exit</span>: (10) 2 is 1+1 ? 
   <span style="color: #BA36A5;">Call</span>: (10) acCount(<span style="color: #0000FF;">[</span>c<span style="color: #0000FF;">]</span>, 2, <span style="color: #BA36A5;">_1850</span>) ? 
   <span style="color: #BA36A5;">Call</span>: (11) <span style="color: #BA36A5;">_2112</span> is 2+1 ? 
   <span style="color: #BA36A5;">Exit</span>: (11) 3 is 2+1 ? 
   <span style="color: #BA36A5;">Call</span>: (11) acCount(<span style="color: #0000FF;">[]</span>, 3, <span style="color: #BA36A5;">_1850</span>) ? 
   <span style="color: #BA36A5;">Exit</span>: (11) acCount(<span style="color: #0000FF;">[]</span>, 3, 3) ? 
   <span style="color: #BA36A5;">Exit</span>: (10) acCount(<span style="color: #0000FF;">[</span>c<span style="color: #0000FF;">]</span>, 2, 3) ? 
   <span style="color: #BA36A5;">Exit</span>: (9) acCount(<span style="color: #0000FF;">[</span>b, c<span style="color: #0000FF;">]</span>, 1, 3) ? 
   <span style="color: #BA36A5;">Exit</span>: (8) acCount(<span style="color: #0000FF;">[</span>a, b, c<span style="color: #0000FF;">]</span>, 0, 3) ? 
<span style="color: #BA36A5;">N</span> = 3.
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orged3c49f" class="outline-4">
<h4 id="orged3c49f"><code>append</code></h4>
<div class="outline-text-4" id="text-orged3c49f">
<ul class="org-ul">
<li><p>
Die Frage <code>append(L1, L2, L3)</code> soll genau dann <code>true</code> liefern, wenn
die Liste <code>L3</code> gleich der Verkettung der Liste <code>L1</code> mit der Liste <code>L2</code> ist.
</p>
<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #006699;">append</span>(<span style="color: #0000FF;">[]</span>,<span style="color: #BA36A5;">L</span>,<span style="color: #BA36A5;">L</span>).
<span style="color: #006699;">append</span>(<span style="color: #0000FF;">[</span><span style="color: #BA36A5;">H</span><span style="color: #0000FF;">|</span><span style="color: #BA36A5;">T</span><span style="color: #0000FF;">]</span>,<span style="color: #BA36A5;">L2</span>,<span style="color: #0000FF;">[</span><span style="color: #BA36A5;">H</span><span style="color: #0000FF;">|</span><span style="color: #BA36A5;">L3</span><span style="color: #0000FF;">]</span>)  :-  append(<span style="color: #BA36A5;">T</span>,<span style="color: #BA36A5;">L2</span>,<span style="color: #BA36A5;">L3</span>).

?- append(<span style="color: #0000FF;">[</span>a,b,c<span style="color: #0000FF;">]</span>,<span style="color: #0000FF;">[</span>1,2,3<span style="color: #0000FF;">]</span>,<span style="color: #0000FF;">[</span>a,b,c,1,2,3<span style="color: #0000FF;">]</span>).
true.

?- append(<span style="color: #0000FF;">[</span>a,<span style="color: #0000FF;">[</span>b,c<span style="color: #0000FF;">]</span>,d<span style="color: #0000FF;">]</span>,<span style="color: #0000FF;">[</span>1,2,3<span style="color: #0000FF;">]</span>,<span style="color: #0000FF;">[</span>a,<span style="color: #0000FF;">[</span>b,c<span style="color: #0000FF;">]</span>,d,1,2,3<span style="color: #0000FF;">]</span>).
true.

?- append(<span style="color: #0000FF;">[</span>a,b,c<span style="color: #0000FF;">]</span>,<span style="color: #0000FF;">[</span>1,2,3<span style="color: #0000FF;">]</span>,<span style="color: #0000FF;">[</span>1,2,3,a,b,c<span style="color: #0000FF;">]</span>).
false.

?- append(<span style="color: #0000FF;">[</span>a,b,c<span style="color: #0000FF;">]</span>,<span style="color: #0000FF;">[</span>1,2,3<span style="color: #0000FF;">]</span>,<span style="color: #BA36A5;">L</span>).
<span style="color: #BA36A5;">L</span> = <span style="color: #0000FF;">[</span>a, b, c, 1, 2, 3<span style="color: #0000FF;">]</span>.

?- append(<span style="color: #0000FF;">[</span>a,b,c<span style="color: #0000FF;">]</span>,<span style="color: #BA36A5;">L</span>,<span style="color: #0000FF;">[</span>a, b, c, 1, 2, 3<span style="color: #0000FF;">]</span>).
<span style="color: #BA36A5;">L</span> = <span style="color: #0000FF;">[</span>1, 2, 3<span style="color: #0000FF;">]</span>.

?- append(<span style="color: #BA36A5;">L1</span>, <span style="color: #BA36A5;">L2</span>, <span style="color: #0000FF;">[</span>a,b,c<span style="color: #0000FF;">]</span>).
<span style="color: #BA36A5;">L1</span> = <span style="color: #0000FF;">[]</span>,
<span style="color: #BA36A5;">L2</span> = <span style="color: #0000FF;">[</span>a, b, c<span style="color: #0000FF;">]</span> <span style="color: #0000FF;">;</span>
<span style="color: #BA36A5;">L1</span> = <span style="color: #0000FF;">[</span>a<span style="color: #0000FF;">]</span>,
<span style="color: #BA36A5;">L2</span> = <span style="color: #0000FF;">[</span>b, c<span style="color: #0000FF;">]</span> <span style="color: #0000FF;">;</span>
<span style="color: #BA36A5;">L1</span> = <span style="color: #0000FF;">[</span>a, b<span style="color: #0000FF;">]</span>,
<span style="color: #BA36A5;">L2</span> = <span style="color: #0000FF;">[</span>c<span style="color: #0000FF;">]</span> <span style="color: #0000FF;">;</span>
<span style="color: #BA36A5;">L1</span> = <span style="color: #0000FF;">[</span>a, b, c<span style="color: #0000FF;">]</span>,
<span style="color: #BA36A5;">L2</span> = <span style="color: #0000FF;">[]</span> <span style="color: #0000FF;">;</span>
false.
</pre>
</div></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org561ea7b" class="outline-3">
<h3 id="org561ea7b">Negation, <code>cut</code> und <code>fail</code></h3>
<div class="outline-text-3" id="text-org561ea7b">
</div>
<div id="outline-container-org8687db9" class="outline-4">
<h4 id="org8687db9">Erzwingen von Backtracking</h4>
<div class="outline-text-4" id="text-org8687db9">
<ul class="org-ul">
<li><p>
Gesucht ist ein Prädikat <code>all/1</code>, das angewendet auf eine Liste
alle Elemente anzeigt:
</p>
<div class="small">
<div class="org-src-container">
<pre class="src src-prolog">?- all(<span style="color: #0000FF;">[</span>a,b,c<span style="color: #0000FF;">]</span>).
a
b
c
true.
</pre>
</div>

</div></li>
</ul>
</div>
<div id="outline-container-org81adf7f" class="outline-5">
<h5 id="org81adf7f">Erste Versuche</h5>
<div class="outline-text-5" id="text-org81adf7f">
<p>
Die Verwendung des Prädikats 
</p>
<pre class="example">
all_0(L) :- member(X,L).
</pre>

<p>
führt zu folgendem Ergebnis:
</p>
<div class="smaller">
<div class="org-src-container">
<pre class="src src-prolog">?- all_0(<span style="color: #0000FF;">[</span>a,b,c<span style="color: #0000FF;">]</span>).
true <span style="color: #0000FF;">;</span>
true <span style="color: #0000FF;">;</span>
true <span style="color: #0000FF;">;</span>
false.
</pre>
</div>

</div>
<p>
Verwendung des Standardprädikats <code>write/1</code>:
</p>
<pre class="example">
all_1(L) :- member(X,L), write(X).
</pre>

<div class="small">
<div class="org-src-container">
<pre class="src src-prolog">?- all_1(<span style="color: #0000FF;">[</span>a,b,c<span style="color: #0000FF;">]</span>).
a
true <span style="color: #0000FF;">;</span>
b
true <span style="color: #0000FF;">;</span>
c
true <span style="color: #0000FF;">;</span>
false.
</pre>
</div>

</div>
</div>
</div>
<div id="outline-container-org388bf6a" class="outline-5">
<h5 id="org388bf6a">Verwendung von <code>fail/0</code></h5>
<div class="outline-text-5" id="text-org388bf6a">
<ul class="org-ul">
<li>Das Prädikat fail/0 schlägt immer fehl.</li>
<li>Seine Verwendung führt daher immer zu Backtracking.</li>
<li><p>
Damit kann hier die Ausgabe aller Elemente ohne Benutzerinteraktion
erreicht werden:
</p>
<div class="smaller">
<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #006699;">all_2</span>(<span style="color: #BA36A5;">L</span>) :- member(<span style="color: #BA36A5;">X</span>,<span style="color: #BA36A5;">L</span>), write(<span style="color: #BA36A5;">X</span>),fail.
?- all_2(<span style="color: #0000FF;">[</span>a,b,c<span style="color: #0000FF;">]</span>).
abc
false.
</pre>
</div>

</div></li>
<li><p>
Beseitigung der „Schönheitsfehler“:
</p>
<div class="small">
<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #006699;">all</span>(<span style="color: #BA36A5;">L</span>):- member(<span style="color: #BA36A5;">X</span>,<span style="color: #BA36A5;">L</span>),writeln(<span style="color: #BA36A5;">X</span>),fail.
<span style="color: #006699;">all</span>(<span style="color: #BA36A5;">_</span>).

?- all(<span style="color: #0000FF;">[</span>a,b,c<span style="color: #0000FF;">]</span>).
a
b
c
true.
</pre>
</div>

</div></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org5b36928" class="outline-4">
<h4 id="org5b36928">Das Standardprädikat <code>!/0</code> (Cut)</h4>
<div class="outline-text-4" id="text-org5b36928">
<p>
(vgl. <a href="http://www.learnprolognow.org/lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch10">Learn Prolog Now</a>)
</p>
<ul class="org-ul">
<li><p>
Gesucht ein Prädikat <code>max/3</code>, das drei ganze Zahlen als Argumente
erwartet und erfüllt ist, wenn das dritte Argument gleich dem
größeren der beiden ersten Argumente ist.
</p>
<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #006699;">max</span>(<span style="color: #BA36A5;">X</span>,<span style="color: #BA36A5;">Y</span>,<span style="color: #BA36A5;">Y</span>):- <span style="color: #BA36A5;">X</span> =&lt; <span style="color: #BA36A5;">Y</span>. 
<span style="color: #006699;">max</span>(<span style="color: #BA36A5;">X</span>,<span style="color: #BA36A5;">Y</span>,<span style="color: #BA36A5;">X</span>):- <span style="color: #BA36A5;">X</span> &gt;  <span style="color: #BA36A5;">Y</span>.

?- max(5,4,5).
true.

?- max(2,3,3).
true <span style="color: #0000FF;">;</span>
false.

?- max(5,4,4).
false.

?- max(5,4,<span style="color: #BA36A5;">X</span>).
<span style="color: #BA36A5;">X</span> = 5.

?- max(2,3,<span style="color: #BA36A5;">X</span>).
<span style="color: #BA36A5;">X</span> = 3 <span style="color: #0000FF;">;</span>
false.
</pre>
</div></li>
<li><code>max/3</code> ist korrekt, aber ineffizient, warum?</li>
</ul>
</div>
<div id="outline-container-org241d2e0" class="outline-5">
<h5 id="org241d2e0">Vermeidung des Backtracking</h5>
<div class="outline-text-5" id="text-org241d2e0">
<ul class="org-ul">
<li>Da die beiden Regeln von <code>max/3</code> sich gegenseitig ausschließen, wäre
es wünschenswert, das Backtracking, für den Fall, dass die erste
Regel erfüllt ist, zu vermeiden, da die zweite nie erfüllt werden kann.</li>
<li><p>
Das ermöglicht der Cut-Operator <code>!/0</code>. 
</p>
<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #006699;">max</span>(<span style="color: #BA36A5;">X</span>,<span style="color: #BA36A5;">Y</span>,<span style="color: #BA36A5;">Y</span>):- <span style="color: #BA36A5;">X</span> =&lt; <span style="color: #BA36A5;">Y</span>, <span style="color: #0000FF;">!</span>. 
<span style="color: #006699;">max</span>(<span style="color: #BA36A5;">X</span>,<span style="color: #BA36A5;">Y</span>,<span style="color: #BA36A5;">X</span>):- <span style="color: #BA36A5;">X</span> &gt;  <span style="color: #BA36A5;">Y</span>.

?- max(2,3,3).
true.

?- max(5,4,<span style="color: #BA36A5;">X</span>).
<span style="color: #BA36A5;">X</span> = 5.

?- max(2,3,<span style="color: #BA36A5;">X</span>).
<span style="color: #BA36A5;">X</span> = 3.
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org214c332" class="outline-5">
<h5 id="org214c332">Wirkungsweise und Nutzen des Cut-Operators</h5>
<div class="outline-text-5" id="text-org214c332">
<ul class="org-ul">
<li>Wirkungsweise:
<ul class="org-ul">
<li>Der Cut wird im Rumpf von Regeln eingesetzt und verhindert Backtracking.</li>
<li>Der Cut gelingt immer.</li>
<li>Nach dem Passieren eines Cuts in einem Regelrumpf sind
<ul class="org-ul">
<li>die Teilziele, die in demselben Regelrumpf vor dem Cut stehen, und</li>
<li>alle weiteren Klauseln desselben Prädikats, die hinter der Regel
stehen, vom weiteren Backtracking ausgeschlossen.</li>
</ul></li>
</ul></li>
<li>Der Cut kann genutzt werden für
<ul class="org-ul">
<li>Effizienzsteigerung</li>
<li>Speichereinsparung</li>
<li>Verkürzung von Programmen</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orge40ad73" class="outline-5">
<h5 id="orge40ad73">Grüne und rote Cuts</h5>
<div class="outline-text-5" id="text-orge40ad73">
<ul class="org-ul">
<li>Der Cut in <code>max/3</code> ändert nichts am Ergebnis des Prädikats gegenüber
der ersten Version ohne Cut. Einen solchen Cut nennt man grün.</li>
<li>Er dient hier der Effizienzsteigerung.</li>
<li><p>
Man könnte auf die Idee kommen, den Rumpf der zweiten Regel als
redundant zu betrachten und das Prädikat dann so schreiben:
</p>
<div class="smaller">
<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #006699;">max</span>(<span style="color: #BA36A5;">X</span>,<span style="color: #BA36A5;">Y</span>,<span style="color: #BA36A5;">Y</span>):- <span style="color: #BA36A5;">X</span> =&lt; <span style="color: #BA36A5;">Y</span>, <span style="color: #0000FF;">!</span>. 
<span style="color: #006699;">max</span>(<span style="color: #BA36A5;">X</span>,<span style="color: #BA36A5;">Y</span>,<span style="color: #BA36A5;">X</span>).
</pre>
</div>

</div></li>
<li>Anfragen der Art <code>max(5,4,X)</code> oder <code>max(2,3,X)</code> werden nach wie vor
korrekt beantwortet.</li>
<li>Die Anfrage <code>max(4,5,4)</code> müsste fehlschlagen, liefert aber <code>true</code>. Warum?</li>
</ul>
<ul class="org-ul">
<li>Da <code>max(4,5,4)</code> nicht mit dem ersten Regelkopf unifizierbar ist,
geht Prolog direkt zur zweiten Klausel, die trivialerweise <code>true</code>
liefert.</li>
</ul>
<ul class="org-ul">
<li><p>
Schreibt man das Prädikat wie folgt um
</p>
<div class="smaller">
<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #006699;">max</span>(<span style="color: #BA36A5;">X</span>,<span style="color: #BA36A5;">Y</span>,<span style="color: #BA36A5;">Z</span>):- <span style="color: #BA36A5;">X</span> =&lt; <span style="color: #BA36A5;">Y</span>, <span style="color: #0000FF;">!</span>, <span style="color: #BA36A5;">Y</span> = <span style="color: #BA36A5;">Z</span>. 
<span style="color: #006699;">max</span>(<span style="color: #BA36A5;">X</span>,<span style="color: #BA36A5;">Y</span>,<span style="color: #BA36A5;">X</span>).  
</pre>
</div>

</div>
<p>
funktioniert wieder alles. Jetzt kann der erste Regelkopf mit
<code>max(4,5,4)</code> unifiziert werden.
</p></li>
<li>Diesen Cut nennt man rot, weil er nicht entfernt werden kann, ohne das Resultat zu
verändern.</li>
</ul>
<blockquote>
<p>
Fazit: Mit Cuts muss man vorsichtig umgehen.
</p>
</blockquote>
</div>
</div>
</div>
<div id="outline-container-org1daaa5e" class="outline-4">
<h4 id="org1daaa5e">Negation mit Cut und <code>fail</code></h4>
<div class="outline-text-4" id="text-org1daaa5e">
<ul class="org-ul">
<li><p>
Keine Regel ohne Ausnahme: Wir wollen festhalten, dass Karl Pizza
mag, außer Salami-Pizza:
</p>
<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #006699;">mag</span>(karl, <span style="color: #BA36A5;">X</span>) :- salami_pizza(<span style="color: #BA36A5;">X</span>),<span style="color: #0000FF;">!</span>,fail.
<span style="color: #006699;">mag</span>(karl, <span style="color: #BA36A5;">X</span>) :- pizza(<span style="color: #BA36A5;">X</span>).

<span style="color: #006699;">pizza</span>(<span style="color: #BA36A5;">X</span>)  :-  vier_jahreszeiten_pizza(<span style="color: #BA36A5;">X</span>).
<span style="color: #006699;">pizza</span>(<span style="color: #BA36A5;">X</span>)  :-  salami_pizza(<span style="color: #BA36A5;">X</span>). 
<span style="color: #006699;">pizza</span>(<span style="color: #BA36A5;">X</span>)  :-  champignon_pizza(<span style="color: #BA36A5;">X</span>).

<span style="color: #006699;">vier_jahreszeiten_pizza</span>(vklein). 
<span style="color: #006699;">vier_jahreszeiten_pizza</span>(vgross). 
<span style="color: #006699;">salami_pizza</span>(s). 
<span style="color: #006699;">champignon_pizza</span>(c).

?- mag(karl,c).
true.

?- mag(karl,s).
false.
</pre>
</div></li>
<li>So weit, so gut aber &#x2026;</li>
</ul>
</div>
<div id="outline-container-org2d32c25" class="outline-5">
<h5 id="org2d32c25">Wirkungsweise und Probleme &#x2026;</h5>
<div class="outline-text-5" id="text-org2d32c25">
<ul class="org-ul">
<li>Wirkungsweise der ersten Regel: 
<ul class="org-ul">
<li>Wenn <code>X=s</code>, ist  <code>salami_pizza(X)</code>  erfüllt.</li>
<li>Wir erreichen den Cut, d.&nbsp;h. die zweite Regel wird nicht
probiert.</li>
<li>Anschließend fordert <code>fail</code> ein Backtracking, was aber vom Cut
verhindert wird.</li>
<li>Das Ergebnis von <code>mag(karl,s)</code> ist also <code>false</code>.</li>
</ul></li>
<li>Probleme
<ul class="org-ul">
<li>Die Regeln des Prädikats <code>mag</code> dürfen nicht vertauscht werden.</li>
<li>Der Cut ist rot.</li>
<li>Außerdem: <code>mag(karl, X)</code> liefert <code>false</code>.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org8066784" class="outline-5">
<h5 id="org8066784">&#x2026; Abhilfe</h5>
<div class="outline-text-5" id="text-org8066784">
<ul class="org-ul">
<li>Die Cut-fail-Kombination stellt eine Art Negation zur Verfügung, die
auch als <i>negation as failure</i> bezeichnet wird.</li>
<li><p>
Versteckt man diese in einem Prädikat <code>neg/1</code>, lässt sich das
<code>mag/1</code>-Prädikat sehr viel prägnanter aufschreiben:
</p>
<div class="smaller">
<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #006699;">neg</span>(<span style="color: #BA36A5;">Ziel</span>)  :-  <span style="color: #BA36A5;">Ziel</span>,<span style="color: #0000FF;">!</span>,fail. 
<span style="color: #006699;">neg</span>(<span style="color: #BA36A5;">Ziel</span>).

<span style="color: #006699;">mag</span>(karl, <span style="color: #BA36A5;">X</span>) :- pizza(<span style="color: #BA36A5;">X</span>), neg(salami_pizza(<span style="color: #BA36A5;">X</span>)).
</pre>
</div>

</div></li>
<li>Karl mag Pizza, aber keine Salami-Pizza.</li>
<li><p>
Statt <code>neg/1</code> kann auch das Standardprädikat <code>\+/1</code> verwendet
werden:
</p>
<pre class="example">
mag(karl, X) :- pizza(X), \+ (salami_pizza(X)).
</pre></li>
<li><p>
Die Frage <code>mag(karl, X)</code> liefert jetzt auch das richtige Ergebnis:
</p>
<div class="smaller">
<div class="org-src-container">
<pre class="src src-prolog">?- mag(karl, <span style="color: #BA36A5;">X</span>).
<span style="color: #BA36A5;">X</span> = vklein <span style="color: #0000FF;">;</span>
<span style="color: #BA36A5;">X</span> = vgross <span style="color: #0000FF;">;</span>
<span style="color: #BA36A5;">X</span> = c.
</pre>
</div>

</div></li>
</ul>
</div>
</div>
<div id="outline-container-orgb236bb5" class="outline-5">
<h5 id="orgb236bb5"><code>\+/1</code> ist keine logische Negation</h5>
<div class="outline-text-5" id="text-orgb236bb5">
<ul class="org-ul">
<li>Das <code>mag/1</code>-Prädikat ist auch in der letzten Fassung nicht
vollständig deklarativ.</li>
<li><p>
Schreibt man das Prädikat als
</p>
<pre class="example">
mag(karl, X) :- \+ (salami_pizza(X)), pizza(X).
</pre>

<p>
liefert <code>mag(karl, X)</code> wieder <code>false</code>.
</p></li>
<li>Man mache sich klar, woran das liegt.</li>
</ul>
</div>
</div>
</div>
</div>
</div>




<div id="outline-container-org2b105ab" class="outline-2">
<h2 id="bibliography">Literaturverzeichnis</h2>
<div class="outline-text-2" id="text-bibliography">
<ul class='org-ref-bib'><li><a id="Bramer2013">[Bramer2013]</a> <a name="Bramer2013"></a>Max Bramer, Logic Programming with Prolog, Springer (2013).</li>
<li><a id="Clocksin2003">[Clocksin2003]</a> <a name="Clocksin2003"></a>William Clocksin & Christopher Mellish, Programming in Prolog: Using the ISO Standard, Springer (2003).</li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Autor: Johannes Brauer</p>
<p class="date">Created: 2019-08-05 Mon 19:14</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>